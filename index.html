<!DOCTYPE html>
<html>

<head>

<title>Roguelike Showdown</title>
<link rel="icon" type="image/x-icon" href="favicon.ico">

<style>
body {
  background-color: black;
  color: white;
  font-family: monospace;
}

.info-box {
  border: 1px solid;
  border-color: inherit;
  border-radius: 6px;
  border-top-right-radius: 0;
  padding: 6px;
  margin: 0px;
  white-space: pre-wrap;
}
.pokemon {
  background-repeat: no-repeat;
  background-position-x: right;
  background-position-y: center;
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
  white-space: pre;
  padding-top: .5rem;
  padding-bottom: .5rem;
}
.move-choice, .pokemon {
  width: 31ch;
}
.pokemon:not(.editable) {
  height: 5rem;
  overflow: hidden;
}
.pokemon.editable {
  box-shadow: inset 0 0 10px white;
  height: 10rem;
  overflow: auto;
}
.chosen>.pokemon.editable {
  /* box-shadow: inset 0 0 10px lightgreen; */
  box-shadow: none;
}
.stats {
  border-top: none;
  border-top-left-radius: 0;
  border-top-right-radius: 0;
  margin-bottom: 2px;
  width: 31ch;
  height: 3rem;
}
.item {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
  width: 55ch;
}
.item-price {
  border-left: none;
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
  width: 7ch;
}
input[type=checkbox]:checked+.item, input[type=checkbox]:checked+.item+.item-price {
  box-shadow: inset 0 0 20px lightblue;
}
.flex-row {
  display: flex;
  flex-direction: row;
  justify-content: left;
}
.flex-col-centered {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
}

.pokemon-div, .flex-col {
  display: flex;
  flex-direction: column;
  justify-content: center;
  position: relative;
  margin: 2px;
  width: min-content;
}
.chosen {
  border-color: lightgreen;
}

.overlay {
  position: absolute;
  top: 0;
  right: 0;
}
.overlay > img {
  margin-right: 1px;
}

.ml-1 {
  margin-left: 1rem;
}
.mb-1 {
  margin-bottom: 1rem;
}
.mt-1 {
  margin-top: 1rem;
}
.mb-4px {
  margin-top: 0px;
  margin-bottom: 4px;
}
.m-0 {
  margin: 0;
}

.checkbox {
  margin: 8px;
}

.text-center {
  text-align: center;
}

.invisible {
  visibility: hidden;
}

button:focus {
  box-shadow: 0 0 0 2px rgba(255,255,255,.5);
}

.gray {
  color: #666;
}
.green {
  color: lightgreen;
}

.hasHoverText {
  text-decoration: dashed underline; 
}

.big-text {
  font-size: large;
  font-weight: 700;
}
.misc { color: lightgray }
.miscParty { background: linear-gradient(45deg, hotpink, lightgray, hotpink); }
.pokeball { background: linear-gradient(0deg, white 50%, lightcoral 50%); }
.heldItem { color: orange }
.heldItemParty { background: linear-gradient(45deg, hotpink, orange, hotpink); }
.TM { color: yellow }
.partyTM { background: linear-gradient(45deg, hotpink, yellow, hotpink); }
.universalTM { background: linear-gradient(45deg, rgba(255,116,0,1) 0%, rgba(255,200,0,1) 20%, rgba(255,255,0,1) 50%, rgba(210,255,0,1) 80%, rgba(99,253,245,1) 100%); }
.TMAndZCrystal { background: linear-gradient(45deg, yellow, orange); } 
.miscParty, .pokeball, .heldItemParty, .partyTM, .universalTM, .TMAndZCrystal {  
  background-clip: text;
  -webkit-background-clip: text;
  color: transparent;
}

.type-normal { color: #A8A878 }
.type-fighting { color: #C03028 }
.type-flying { color: #A890F0 }
.type-poison { color: #A040A0 }
.type-ground { color: #E0C068 }
.type-rock { color: #B8A038 }
.type-bug { color: #A8B820 }
.type-ghost { color: #705898 }
.type-steel { color: #B8B8D0 }
.type-fire { color: #F08030 }
.type-water { color: #6890F0 }
.type-grass { color: #78C850 }
.type-electric { color: #F8D030 }
.type-psychic { color: #F85888 }
.type-ice { color: #98D8D8 }
.type-dragon { color: #7038F8 }
.type-dark { color: #705848 }
.type-fairy { color: #EE99AC }

.attr { color: #A0A0A0 }

.stat-hp { color: #FF0000 }
.stat-atk { color: #F08030 }
.stat-def { color: #F8D030 }
.stat-spa { color: #6890F0 }
.stat-spd { color: #78C850 }
.stat-spe { color: #F85888 }
</style>
</head>

<body>

<div class="flex-row">
  <div>
    <h1>Roguelike Showdown</h1>
    <label for="pokeball">PokÃ© Ball:</label>
    <select id="pokeball" class="mb-4px">
      <option>PokÃ© Ball</option>
      <option>Great Ball</option>
      <option>Ultra Ball</option>
      <option>Level Ball</option>
      <option>Master Ball</option>
    </select>
    <label for="type">Guaranteed type:</label>
    <select id="type" class="mb-4px">
      <option></option>
      <option>Normal</option>
      <option>Fire</option>
      <option>Water</option>
      <option>Grass</option>
      <option>Electric</option>
      <option>Ice</option>
      <option>Fighting</option>
      <option>Poison</option>
      <option>Ground</option>
      <option>Flying</option>
      <option>Psychic</option>
      <option>Bug</option>
      <option>Rock</option>
      <option>Ghost</option>
      <option>Dark</option>
      <option>Dragon</option>
      <option>Steel</option>
      <option>Fairy</option>
    </select>
    <br>
    <button id="winRound" onclick="winRound()" class="mb-4px">win</button>
    <button id="loseRound" onclick="loseRound()">lose</button>
    <div id="choices" class="flex-row"></div>
    <div class="flex-col-centered">
      <button id="skip" onclick="skipPokemonChoice()">skip</button>
    </div>
    <hr class="mt-1">
    <label for="money">$</label> <input id="money" type="number">
    <button onclick="refreshShop(true)" id="refresh">refresh</button>
    <div id="shop"></div>
    <hr class="mt-1">
    <div class="mb-1">
      <label for="speciesInput">Generate one of species: </label><input id="speciesInput">
      <button onclick="generateOneOfSpecies()">generate</button>
    </div>
    <p id="speciesError" style="display:none">ERROR: species name not recognized</p>
    <div id="species" class=""></div>
  </div>
  <div id="party" class="ml-1">
    <h2 class="text-center">Party <button onclick="copyParty()" class="clipboard-button">ðŸ“‹</button></h2>
    <div class="flex-row">
      <div class="pokemon-div"></div>
      <div class="pokemon-div"></div>
    </div>
    <div class="flex-row">
      <div class="pokemon-div"></div>
      <div class="pokemon-div"></div>
    </div>
    <div class="flex-row">
      <div class="pokemon-div"></div>
      <div class="pokemon-div"></div>
    </div>
  </div>
</div>


<script>

const STATS = ['HP', 'Atk', 'Def', 'SpA', 'SpD', 'Spe'];
// 1st number is index of stat raised, 2nd number is index of stat lowered
const NATURES = {Hardy: [1,1], Lonely: [1,2], Adamant: [1,3], Naughty: [1,4], Brave: [1,5], 
Bold: [2,1], Docile: [2,2], Impish: [2,3], Lax: [2,4], Relaxed: [2,5], 
Modest: [3,1], Mild: [3,2], Bashful: [3,3], Rash: [3,4], Quiet: [3,5], 
Calm: [4,1], Gentle: [4,2], Careful: [4,3], Quirky: [4,4], Sassy: [4,5], 
Timid: [5,1], Hasty: [5,2], Jolly: [5,3], Naive: [5,4], Serious: [5,5]};
const TYPES = ['Normal', 'Fire', 'Water', 'Grass', 'Electric',
  'Ice', 'Fighting', 'Poison', 'Ground', 'Flying',
  'Psychic', 'Bug', 'Rock', 'Ghost', 'Dark', 
  'Dragon', 'Steel', 'Fairy'];

const STAT_TOTAL_GOAL = 650;
const BASE_ABILITY_VALUE = 660/650;
const FOUR_POINT_FIVE_ABILITY_VALUE = 700/650;
const SPECIES_VALUES = {
  'pokestarspirit': Infinity, // so it generates as Lv 1
  'cramorantgulping': 650/(650 - 2 * (150/4 + 100/3)), // since it'll be higher Lv, i figure it'll trigger more often
  'cramorantgorging': 650/(650 - 1.5 * (150/4 + 50 + 50)),
  'wishiwashischool': (650 - 150/4)/650,
  'eiscuenoice': 1,
  'mimikyubusted': 1,
  'mimikyubustedtotem': 1,
}
const ABILITY_VALUES = {
  'Beads of Ruin': 650/625, // SpD drop
  'Sword of Ruin': 650/625, // Def drop
  'Tablets of Ruin': 650/610, // Atk drop
  'Vessel of Ruin': 650/610, // SpA drop
  
  'Desolate Land': 700/650, // sunny + no water while in battle
  'Primordial Sea': 700/650, // rain + no fire while in battle
  'Drizzle': 700/650,
  'Drought': 700/650,
  'Sand Stream': 700/650,
  'Snow Warning': 700/650,
  'Orichalcum Pulse': (700 + 33)/650,
  'Hadron Engine': (650 + 25 + 33)/650,
  
  'Intrepid Sword': 690/650,
  'Dauntless Shield': 690/650,

  'Huge Power': 750/650,
  'Pure Power': 750/650,

  // Arena Trap & Shadow Tag seem less OP in Doubles

  'Contrary': FOUR_POINT_FIVE_ABILITY_VALUE,
  'Fluffy': 690/650,  // x.5 damage from contact moves; *2 from fire
  'Fur Coat': 730/650,  // double DEF
  'Good as Gold': FOUR_POINT_FIVE_ABILITY_VALUE, 
  'Gorilla Tactics': 700/650, // x1.5 Atk; choiced
  'Ice Scales': 730/650, // x.5 damage from special moves
  // Illusion is weakened by varying levels
  'Imposter': 1.3,
  'Intimidate': 650/600,
  'Moody': 690/650,
  'Parental Bond': 700/650,
  'Regenerator': FOUR_POINT_FIVE_ABILITY_VALUE,
  'Speed Boost': 700/650,
  // Stakeout seems less OP in Doubles
  'Water Bubble': 750/650, // x2 water power; can't be burned; fire resistance
  'Wonder Guard': 800/650,

  'Defeatist': 610/650,
  // Klutz isn't bad enough in this context to warrant adjusting
  'Slow Start': 550/650,
  'Stall': (650-79)/650,
  'Truant': 550/650,
};

const AVG_HELD_ITEM_VALUE = 20 * .5; // take into account prob. each Pokemon has a held item

const NUM_SHOP_OPTIONS = 3;
const WIN_INCOME = 100;
const LOSE_INCOME = 120;
const BASE_REFRESH_COST = 5;
const DELTA_REFRESH_COST = 0;

const ILLEGAL_FORMES = ['Gmax', 'Rapid-Strike-Gmax', 'Low-Key-Gmax'];
const ILLEGAL_MONS = [
  // functionally identical because of their ability, and...
  //    misleading type
  'castformsunny', 'castformrainy', 'castformsnowy',
  //    diferent stat total -> different level
  'wishiwashi',
  'miniormeteor',
  // misleadingly, a cap Pikachu that can't use Pikashunium Z. can't use Pikanium Z or cosplay moves, either.
  'pikachuworld',
];
const IDENTICAL_MONS = [
  ['sinistea', 'sinisteaantique'],
  ['polteageist', 'polteageistantique'],
  ['pikachuoriginal', 'pikachuhoenn', 'pikachusinnoh', 'pikachuunova', 'pikachukalos', 'pikachualola', 'pikachupartner'],
  ['magearna', 'magearnaoriginal'],
  ['pichu', 'pichuspikyeared'], 
  ['xerneas', 'xerneasneutral'],
  ['zarude', 'zarudedada'],
  ['keldeo', 'keldeoresolute'],
  ['cherrim', 'cherrimsunshine'],
  // identical except for hidden ability
  ['squawkabilly', 'squawkabillyblue', 'squawkabillyyellow', 'squawkabillywhite'],
  // identical but for 1 move
  ['pikachucosplay', 'pikachurockstar', 'pikachubelle', 'pikachupopstar', 'pikachuphd', 'pikachulibre'],
  // identical but for 1 ability (or for White-Stripe, 1 move)
  ['basculin', 'basculinbluestriped', 'basculinwhitestriped'],
  // identical but for Hold Hands/presence of hidden ability
  [...Array(18).fill('vivillon'), 'vivillonfancy', 'vivillonpokeball'],
  // identical except for Techno Blast's type (and whether it holds an item)
  ['genesect', 'genesectdouse', 'genesectshock', 'genesectburn', 'genesectchill'],
  // identical except for weight
  ['maushold', 'mausholdfour'],
  ['dudunsparce', 'dudunsparcethreesegment'],
  // identical but for 1 move & 1 ability
  ['toxtricity', 'toxtricitylowkey'],
  // identical but for the starting type of 1 move
  ['morpeko', 'morpekohangry'],
  // identical except for weight and ability possibilities
  ['raticatealola', 'raticatealolatotem'],
  ['marowakalola', 'marowakalolatotem'],
  ['gumshoos', 'gumshoostotem'],
  ['vikavolt', 'vikavolttotem'],
  ['ribombee', 'ribombeetotem'],
  ['araquanid', 'araquanidtotem'],
  ['lurantis', 'lurantistotem'],
  ['salazzle', 'salazzletotem'],
  ['togedemaru', 'togedemarutotem'],
  ['mimikyu', 'mimikyutotem'],
  ['mimikyubusted', 'mimikyubustedtotem'],
  ['kommoo', 'kommoototem'],
  // different type OR stats is sufficient for exclusion, even for interchangable formes, 
  // provided forme change is not instantaneous
];

// for testing/studying purposes
let isCalculatingStats = false;
let levelStats;
let statStats;
function printStats() {
  isCalculatingStats = true;
  levelStats = '';
  statStats = [[], [], [], [], [], []];
  for (const species of Object.values(allSpecies)) {
    randomOfSpecies(species.name);
  }
  console.log(levelStats);
  console.log(statStats);
  isCalculatingStats = false;
}
function printMints() {
  let mintTsv = '';
  for (const nature of Object.keys(NATURES)) {
    const raisedStat = STATS[NATURES[nature][0]];
    const loweredStat = STATS[NATURES[nature][1]];
    if (raisedStat === loweredStat)
      continue; // skip neutral natures
    let price = 5;
    if (loweredStat === 'Atk' || loweredStat === 'SpA')
      price = 10;
    mintTsv += nature + ' Mint\tmisc\t' + price 
      + "\tSet a Pokemon's Nature to " + nature + ' (+' + raisedStat + ', -' + loweredStat + ').\n';
  }
  console.log(mintTsv);
}
function printEncounterPowers() {
  let tsv = '';
  for (const type of TYPES) {
    tsv += 'Encounter Power: ' + type + '\tmisc\t\t\t'
      + "\tNext round, you are guaranteed to get " + spanWithType(type, type) + '-type Pokemon.\n';
  }
  console.log(tsv);
}
function printPlatesAndMemories() {
  let tsv = '';
  let speciesIds = Object.keys(allSpecies).filter(speciesId => speciesId.startsWith('arceus'));
  for (const type of TYPES) {
    if (type === 'Normal')
      continue;
    const itemName = allSpecies['arceus' + type.toLowerCase()].requiredItems?.[0];
    tsv += itemName + '\theldItem\t\t\t' + speciesIds.join(',') + '\n';
  }
  speciesIds = Object.keys(allSpecies).filter(speciesId => speciesId.startsWith('silvally'));
  for (const type of TYPES) {
    if (type === 'Normal')
      continue;
    const itemName = allSpecies['silvally' + type.toLowerCase()].requiredItem;
    tsv += itemName + '\theldItem\t\t\t' + speciesIds.join(',') + '\n';
  }
  console.log(tsv);
}
function printZCrystals() {
  let tsv = '';
  for (const heldItem of Object.values(heldItems)) {
    if (heldItem.desc.startsWith('If holder has a'))
      tsv += heldItem.name + '\theldItem\n';
  }
  for (const heldItem of Object.values(heldItems)) {
    if (!heldItem.desc.startsWith('If holder has a') && heldItem.name.endsWith(' Z')) {
      let preZMove;
      const itCanUseIndex = heldItem.desc.indexOf(', it can use ');
      if (itCanUseIndex !== -1) {
        const withIndex = heldItem.desc.indexOf('with ');
        preZMove = heldItem.desc.substring(withIndex + 'with '.length, itCanUseIndex);
      } else if (heldItem.name === 'Lunalium Z')
        preZMove = 'Moongeist Beam'
      else if (heldItem.name === 'Solganium Z')
        preZMove = 'Sunsteel Strike'
      else if (heldItem.name === 'Ultranecrozium Z')
        preZMove = 'Photon Geyser'
      tsv += preZMove + ' TM & ' + heldItem.name + '\tTMAndZCrystal\n';
    }
  }
  console.log(tsv);
}

let allSpecies;
loadAllSpecies();
let learnsets;
loadLearnsets();
let moves;
loadMoves();
let abilities;
loadAbilities();
let heldItems;
loadHeldItems();
let items = [];
loadItems();

fillPartyDivs();

document.getElementById('speciesInput').addEventListener('keyup', function(event) {
  if (event.key === 'Enter') {
    event.preventDefault();
    generateOneOfSpecies();
  }
})

document.getElementById('pokeball').selectedIndex = 0;
document.getElementById('type').selectedIndex = 0;
document.getElementById('winRound').textContent = 'win ($' + WIN_INCOME + ')';
document.getElementById('loseRound').textContent = 'lose ($' + LOSE_INCOME + ')';
document.getElementById('loseRound').disabled = true;
document.getElementById('skip').hidden = true;
document.getElementById('money').value = 0;
document.getElementById('refresh').disabled = true;

function loadAllSpecies() {
  const xhttp = new XMLHttpRequest();
  xhttp.onload = function() {
    allSpecies = JSON.parse(this.responseText);
  }
  xhttp.open("GET", "pokedex.json");
  xhttp.send();
}
function loadLearnsets() {
  const xhttp = new XMLHttpRequest();
  xhttp.onload = function() {
    learnsets = JSON.parse(this.responseText);
  }
  xhttp.open("GET", "learnsets.json");
  xhttp.send();
}
function loadMoves() {
  const xhttp = new XMLHttpRequest();
  xhttp.onload = function() {
    moves = JSON.parse(this.responseText);
  }
  xhttp.open("GET", "moves.json");
  xhttp.send();
}
function loadAbilities() {
  const xhttp = new XMLHttpRequest();
  xhttp.onload = function() {
    abilities = JSON.parse(this.responseText);
  }
  xhttp.open("GET", "abilities.json");
  xhttp.send();
}
function loadHeldItems() {
  const xhttp = new XMLHttpRequest();
  xhttp.onload = function() {
    heldItems = JSON.parse(this.responseText);
  }
  xhttp.open("GET", "heldItems.json");
  xhttp.send();
}
function loadItems() {
  const xhttp = new XMLHttpRequest();
  xhttp.onload = function() {
    const responseLines = this.response.split('\n');
    for (let i = 1; i < responseLines.length; i++) {
      const splitByTab = responseLines[i].split('\t');

      const item = {
        name: splitByTab[0],
        type: splitByTab[1],
        price: splitByTab[2],
        desc: splitByTab[5],
      }
      if (splitByTab[3] !== '')
        item.weight = splitByTab[3];
      if (splitByTab[4] !== '')
        item.requiredSpecies = splitByTab[4].split(',');
      items.push(item);
    }
  }
  xhttp.open("GET", 'items.tsv');
  xhttp.send();
}

function fillPartyDivs() {
  for (const pokemonDiv of document.getElementById('party').getElementsByClassName('pokemon-div')) {
    fillPokemonDiv(pokemonDiv);
    const pokemonEle = pokemonDiv.querySelector('.pokemon');
    pokemonEle.setAttribute('contenteditable', true);
    pokemonEle.setAttribute('spellcheck', false);
    pokemonEle.classList.add('editable');
    pokemonEle.addEventListener('focusout', function() {updatePokemonDiv(pokemonDiv)}, false);
  }
}
function fillPokemonDiv(div) {
  const pokemonEle = document.createElement('p');
  pokemonEle.classList.add('info-box', 'pokemon');
  div.append(pokemonEle);

  const typesEle = document.createElement('div');
  typesEle.classList.add('overlay');
  div.append(typesEle);

  const statsEle = document.createElement('p');
  statsEle.classList.add('info-box', 'stats');
  div.append(statsEle);
}
function updatePokemonDiv(div) {
  const pokemonEle = div.querySelector('.pokemon');
  const pokemonStr = pokemonEle.innerText;

  if (pokemonStr.trim() === '') {
    pokemonEle.style.backgroundImage = '';
    killAllChildren(div.querySelector('.overlay'));
    div.querySelector('.stats').innerHTML = '';
    return;
  }

  pokemonEle.innerHTML = pokemonInHTML(pokemonStr);

  const speciesName = getSpeciesNameOfPokemon(pokemonStr);
  pokemonEle.style.backgroundImage = getImageURL(speciesName);

  const typesEle = div.querySelector('.overlay');
  killAllChildren(typesEle);
  for (const type of allSpecies[getSpeciesId(speciesName)].types) {
    const typeImage = document.createElement('img');
    typeImage.src = 'https://play.pokemonshowdown.com/sprites/types/' + type + '.png';
    typesEle.append(typeImage);
  }

  const statsEle = div.querySelector('.stats');
  statsEle.innerHTML = statsInHTML(pokemonStr);
}

function getSpeciesId(speciesName) {
  return Object.keys(allSpecies).find(speciesId => allSpecies[speciesId].name === speciesName 
    || allSpecies[speciesId].cosmeticFormes?.includes(speciesName));
}
function getMoveId(moveName) {
  return Object.keys(moves).find(moveId => moves[moveId].name === moveName);
}
function getAbilityId(abilityName) {
  return Object.keys(abilities).find(abilityId => abilities[abilityId].name === abilityName);
}
function getHeldItemId(heldItemName) {
  return Object.keys(heldItems).find(heldItemId => heldItems[heldItemId].name === heldItemName);
}

function killAllChildren(div) {
  while (div.firstChild)
    div.removeChild(div.firstChild);
}

function addChoices(choicesDiv) {
  if (getPokeball() === 'Master Ball') {
    const speciesName = prompt('Choose a species (case-sensitive).');
    const speciesId = getSpeciesId(speciesName);
    if (!speciesId) {
      alert('Error: species name not recognized.');
      return false;
    }
    for (const ability of Object.values(allSpecies[speciesId].abilities))
      addRandomPokemon(choicesDiv, true, speciesName, ability);
  } else {
    for (let i = 0; i < numChoices(); i++)
      addRandomPokemon(choicesDiv, true);
  }
  return true;
}
function numChoices() {
  switch (getPokeball()) {
    case 'Great Ball':
    case 'Level Ball':
      return 3;
    case 'Ultra Ball':
      return 4;
    default:
      return 2;
  }
}

function generateOneOfSpecies() {
  const speciesDiv = document.getElementById('species');
  const speciesName = document.getElementById('speciesInput').value.trim();
  addRandomPokemon(speciesDiv, false, speciesName);

  // // list all formes
  // let formes = {};
  // for (const speciesId of Object.keys(allSpecies)) {
  //   if (allSpecies[speciesId].forme) {
  //     if (!formes[allSpecies[speciesId].forme])
  //       formes[allSpecies[speciesId].forme] = [];
  //     formes[allSpecies[speciesId].forme].push(speciesId);
  //   }
  // }
  // console.log(formes);
}

function isLegal(speciesId, species, requiredType) {
  if (species.forme && ILLEGAL_FORMES.includes(species.forme))
    return false;
  if (ILLEGAL_MONS.includes(speciesId))
    return false;
  const identicals = IDENTICAL_MONS.find(arr => arr.includes(speciesId));
  if (identicals && speciesId != randomElement(identicals)) // each forme has a 1/n chance of being legal
    return false;
  if (requiredType && !species.types.includes(requiredType))
    return false;
  return true;
}

function addRandomPokemon(choicesDiv, hasChooseButton, speciesName, ability) {  
  if (speciesName === undefined) {
    let speciesId = randomKey(allSpecies);
    // speciesId = 'houndoommega';
    let species = allSpecies[speciesId];
    let requiredType = document.getElementById('type').value;
    if (!TYPES.includes(requiredType))
      requiredType = null;
    while (!isLegal(speciesId, species, requiredType)) {
      speciesId = randomKey(allSpecies);
      species = allSpecies[speciesId];
    }

    speciesName = species.name;

    if (species.cosmeticFormes && !isPokestar(speciesId)) {
      const randy = randomInt(species.cosmeticFormes.length + 1);
      if (randy < species.cosmeticFormes.length)
        speciesName = species.cosmeticFormes[randy];
    }
  }
  
  const speciesErrorEle = document.getElementById('speciesError');
  if (!getSpeciesId(speciesName)) {
    speciesErrorEle.style.display = 'initial';
    return;
  } else {
    speciesErrorEle.style.display = 'none';
  }
  
  const pokemonStr = randomOfSpecies(speciesName, ability);

  const divEle = document.createElement('div');
  divEle.classList.add('pokemon-div');

  fillPokemonDiv(divEle);

  const pokemonEle = divEle.querySelector('.pokemon');
  pokemonEle.innerHTML = pokemonStr;

  if (hasChooseButton) {
    const buttonEle = document.createElement('button');
    buttonEle.innerText = 'choose';
    buttonEle.onclick = function() {choosePokemon(choicesDiv, pokemonStr)};
    divEle.append(buttonEle);
  }

  updatePokemonDiv(divEle);

  choicesDiv.prepend(divEle);
}

function isPokestar(speciesId) {
  return speciesId.startsWith('pokestar');
}

function getImageURL(speciesName) {
  return 'url(https://play.pokemonshowdown.com/sprites/gen5/' + getImageUrlName(speciesName) + '.png)';
}
function getImageUrlName(speciesName) {
  if (speciesName === 'Unown-Question')
    return 'unown-qm';
  if (speciesName === 'Unown-Exclamation')
    return 'unown-em';
  const species = allSpecies[getSpeciesId(speciesName)];
  if (species.baseSpecies || species.cosmeticFormes?.includes(speciesName)) {
    let baseSpeciesName = species.baseSpecies ?? species.name;
    let formeName = speciesName.substring(baseSpeciesName.length + 1);
    speciesName = baseSpeciesName.replaceAll('-', '') + '-' + formeName.replaceAll('-', '');
  } else {
    speciesName = speciesName.replaceAll('-', '');
  }
  if (speciesName.includes('FlabÃ©bÃ©'))
    speciesName = speciesName.replace('FlabÃ©bÃ©', 'Flabebe');
  return speciesName.toLowerCase().replaceAll(/[^a-zA-Z0-9\-]/g, '');
}

function randomOfSpecies(speciesName, abilityName) {
  const speciesId = getSpeciesId(speciesName);
  const species = allSpecies[speciesId];

  let displayName = speciesName;
  let gender;
  let heldItemName;

  if (species.gender)
    gender = species.gender;
  else {
    let probMale = .5;
    if (species.genderRatio)
      probMale = species.genderRatio.M;
    gender = Math.random() < probMale ? 'M' : 'F';
  }

  if (species.baseSpecies === 'Arceus') {
    displayName = species.baseSpecies;
    heldItemName = species.requiredItems[0];
  }
  else if (species.baseSpecies === 'Silvally' || species.baseSpecies === 'Genesect') {
    displayName = species.baseSpecies;
    heldItemName = species.requiredItem;
  }

  let pokemonStr = displayName;
  if (gender !== 'N')
    pokemonStr += ' (' + gender + ')';
  if (heldItemName)
    pokemonStr += ' @ ' + heldItemName;

  if (abilityName === undefined)
    abilityName = randomProperty(species.abilities);
  pokemonStr += '\nAbility: ';
  if (abilityName)
    pokemonStr += abilityName;

  let statTotalMultiplier = 1;
  // we want: stat goal * ability value = base stat goal * base ability value
  if (SPECIES_VALUES[speciesId])
    statTotalMultiplier = BASE_ABILITY_VALUE / SPECIES_VALUES[speciesId];
  else if (ABILITY_VALUES[abilityName])
    statTotalMultiplier = BASE_ABILITY_VALUE / ABILITY_VALUES[abilityName];
  let level = getLevel(species, STAT_TOTAL_GOAL * statTotalMultiplier); 
  if (speciesId === 'palafin')
    level = getLevel(allSpecies.palafinhero, STAT_TOTAL_GOAL * 680/650); 
  else if (abilityName === 'Power Construct')
    level = (level + getLevel(allSpecies.zygardecomplete, STAT_TOTAL_GOAL)) / 2;

  if (getPokeball() === 'Level Ball')
    level -= 1;

  pokemonStr += '\nLevel: ' + level;

  if (isCalculatingStats) {
    levelStats += level + ', ';
    for (let i = 0; i < STATS.length; i++) {
      statStats[i].push(getStat(species, level, 'EVs: 1 HP', null, STATS[i]));
    }
  }

  if (canTera(species, heldItems[getHeldItemId(heldItemName)]))
    pokemonStr += '\nTera Type:';
    
  pokemonStr += '\nEVs: 1 HP';

  return pokemonStr;
}

function getLearnset(speciesId) {
  const species = allSpecies[speciesId];
  let learnset;
  if (isPokestar(speciesId)) {
    learnset = new Set();
    for (const eventDatum of learnsets[speciesId].eventData)
      for (const moveId of eventDatum.moves)
        learnset.add(moveId);
  } else {
    let learnsetData = learnsets[speciesId];

    if (!learnsetData?.learnset)
      learnsetData = learnsets[species.baseSpecies.toLowerCase()];

    learnset = new Set(Object.keys(learnsetData.learnset));

    let baseSpeciesId = speciesId;
    if (learnset.size < 4) {
      let changesFrom;
      if (species.changesFrom)
        changesFrom = species.changesFrom;
      else if (species.baseSpecies)
        changesFrom = species.baseSpecies;
      
      if (changesFrom) {
        baseSpeciesId = getSpeciesId(changesFrom);
        const baseSepeciesLearnset = Object.keys(learnsets[baseSpeciesId].learnset);
        for (const moveId of baseSepeciesLearnset)
          learnset.add(moveId);
      }
    }

    const preEvoName = allSpecies[baseSpeciesId].prevo;
    if (preEvoName) {
      const preEvoLearnset = getLearnset(getSpeciesId(preEvoName));
      for (const moveId of preEvoLearnset)
        learnset.add(moveId)
    }
  }
  return Array.from(learnset);
}

function getLevel(species, statTotalGoal) {
  let prevStatTotal = Number.NEGATIVE_INFINITY;
  for (let level = 1; level <= 100; level++) {
    const statTotal = getStatTotal(species, level, 'EVs: 1 HP', null);
    if (statTotal > statTotalGoal) {
      if (statTotalGoal - prevStatTotal < statTotal - statTotalGoal)
        return level-1;
      else
        return level;
    }
    prevStatTotal = statTotal;
  }
  return 100;
}

function getSpeciesNameOfPokemon(pokemonStr) {
  let firstLine = pokemonStr.split('\n')[0];
  let name = firstLine;
  if (name.includes(' @'))
    name = name.substring(0, name.indexOf(' @'));
  if (name.includes(' ('))
    name = name.substring(0, name.indexOf(' ('));
  if (firstLine.includes(' @ ')) {
    let heldItem = firstLine.split(' @ ')[1];
    let holdingItemForme = Object.values(allSpecies).find(species => species.baseSpecies === name && 
                      (species.requiredItem === heldItem || species.requiredItems?.includes(heldItem)));
    if (heldItem === 'Ultranecrozium Z')
      if (name === 'Necrozma-Dusk-Mane' || name === 'Necrozma-Dawn-Wings')
        name = 'Necrozma-Ultra';
      else
        holdingItemForme = null;
    if (holdingItemForme)
      name = holdingItemForme.name;
  }
  return name;
}
function getSpeciesIdOfPokemon(pokemonStr) {
  return getSpeciesId(getSpeciesNameOfPokemon(pokemonStr));
}

function pokemonInHTML(pokemonStr) {
  const strLines = pokemonStr.split('\n');
  out = '';

  const speciesId = getSpeciesIdOfPokemon(pokemonStr);
  const species = allSpecies[speciesId];

  let heldItem;

  for (let i = 0; i < strLines.length; i++) {
    let strLine = strLines[i].trimEnd();

    if (i === 0) {
      let firstLine = strLine;
      if (strLine.includes(' @ ')) {
        strLineSplit = strLine.split(' @ ');
        heldItem = heldItems[getHeldItemId(strLineSplit[1])];
        firstLine = strLineSplit[0] + ' @ ' + heldItemInHTML(strLineSplit[1]);
      }
      out += firstLine;
    } else if (strLine.startsWith('Ability: ')) {
      out += spanWithClass('Ability: ', 'attr');
      const abilityName = strLine.substring('Ability: '.length);
      const ability = abilities[getAbilityId(abilityName)];
      if (ability)
        out += spanWithTitle(abilityName, ability.shortDesc);
      
    } else if (strLine.startsWith('Level: ')) {
      const level = parseInt(strLine.substring('Level: '.length));
      if (level === getLevel(species, STAT_TOTAL_GOAL))
        out += spanWithClass(strLine, 'gray');
      else
        out += spanWithClass('Level: ', 'attr') + level;
      
    } else if (strLine.startsWith('Tera Type:')) {
      const teraType = strLine.substring('Tera Type: '.length);
      if (!canTera(species, heldItem)) {
        out += spanWithClass(strLine, 'gray');
      } else {
        out += spanWithClass('Tera Type: ', 'attr');
        out += spanWithType(teraType, teraType);
      }

    } else if (strLine.startsWith('EVs: ')) {
      if (strLine === 'EVs: 1 HP') {
        out += spanWithClass(strLine, 'gray');
      } else {
        out += spanWithClass('EVs: ', 'attr');
        const statStrs = strLine.substring('EVs: '.length).split('/');
        for (const statStr of statStrs) {
          const splitBySpace = statStr.trim().split(' ');
          const statNum = parseInt(splitBySpace[0]);
          const stat = splitBySpace[1];
          if (statNum < 4)
            out += spanWithClass(statStr, 'gray') + '/';
          else
            out += spanWithClass(statStr, 'stat-' + stat.toLowerCase()) + '/';
        }
        out = out.slice(0, -1);
      }

    } else if (strLine.endsWith(' Nature')) {
      const nature = strLine.slice(0, -1 * ' Nature'.length);
      const raisedStat = STATS[NATURES[nature][0]];
      const loweredStat = STATS[NATURES[nature][1]];
      const titleText = '+' + raisedStat + ', -' + loweredStat;
      out += spanWithTitle(nature, titleText) + ' Nature';

    } else if (strLine.startsWith('-')) {
      const moveName = strLine.substring('- '.length);
      if (moveName === '')
        out += spanWithClass('-', 'gray');
      else
        out += moveInHTML(moveName, '- ');
    } else {
      out += strLine;
    }
    out += '\n';
  }

  return out.slice(0, -1);
}
function moveInHTML(moveName, prefix) {
  if (prefix === undefined)
    prefix = '';

  const move = moves[getMoveId(moveName)];
  const type = move.type;

  return spanWithType(prefix + spanWithTitle(moveName, moveDesc(move, type)), type);
}
function moveDesc(move, type) {
  let title = 'Type: ' + type + '\nCat: ' + move.category;
  if (move.basePower && move.basePower !== 0)
    title += '\nPow: ' + move.basePower;
  if (move.accuracy && move.accuracy !== true)
    title += '\nAcc: ' + move.accuracy;
  if (move.pp === 1)
    title += '\nPP: 1';
  let shortDesc = move.shortDesc;
  if (move.name.startsWith('Hidden Power'))
    shortDesc = "A Pokemon can only know 1 Hidden Power at a time."
  title += '\n\n' + shortDesc;
  return title;
}

function pokemonCanTera(pokemonStr) {
  const species = allSpecies[getSpeciesIdOfPokemon(pokemonStr)];
  const heldItem = heldItems[getHeldItemId(pokemonStr.split('\n')[0].split(' @ ')[1])];
  return canTera(species, heldItem);
}
function canTera(species, heldItem) {
  if (species.forme && 
    (species.forme.includes('Mega') || species.forme === 'Primal' || species.forme === 'Ultra'))
    return false;
  if (heldItem) {
    if (heldItem.name.endsWith(' Z'))
      return false;
    if ((heldItem.desc.includes('Mega Evolve') || heldItem.desc.includes('Primal Reversion'))
          && heldItem.desc.includes(species.name))
      return false;
  }
  return true;
}

function statsInHTML(pokemonStr) {
  const speciesId = getSpeciesIdOfPokemon(pokemonStr);
  const species = allSpecies[speciesId];
  const strLines = pokemonStr.split('\n');

  const levelStr = strLines.find(line => line.startsWith('Level: '));
  const level = levelStr ? parseInt(levelStr.substring('Level: '.length)) : 100;

  const evsStr = strLines.find(line => line.startsWith('EVs: '));

  const nature = strLines.find(line => line.trim().endsWith(' Nature'))?.slice(0, -1 * ' Nature'.length);

  let out = '';
  for (const stat of STATS) {
    const statNum = getStat(species, level, evsStr, nature, stat);
    let statStr = statNum + ' ' + stat;
    if (stat === 'Atk' || stat === 'SpA')
      statStr = spanWithTitle(statStr, 'Unadjusted ' + stat + ': ' + getUnadjustedStat(species, level, evsStr, nature, stat));
    out += spanWithClass(' '.repeat(3-(statNum+'').length) + statStr, 'stat-' + stat.toLowerCase()) + ' ';
    if (stat === 'Def')
      out += '\n' + ' '.repeat('... HP '.length);
  }
  out = out.slice(0, -1);

  const statTotal = getStatTotal(species, level, evsStr, nature);
  let statTotalStr = '';
  if (statTotal === getStatTotal(species, getLevel(species, STAT_TOTAL_GOAL), 'EVs: 1 HP', null))
    statTotalStr += spanWithClass('TOTAL: ' + statTotal, 'gray');
  else
    statTotalStr += spanWithClass('TOTAL: ', 'attr') + statTotal;
  out = statTotalStr + '\n' + out;

  return out;
}

function getStatTotal(species, level, evsStr, nature) {
  let statTotal = 0;
  for (const stat of STATS)
    statTotal += getStat(species, level, evsStr, nature, stat);
  return statTotal;
}
function getStat(species, level, evsStr, nature, stat) {
  const actualStat = getUnadjustedStat(species, level, evsStr, nature, stat);
  if (stat === 'Atk' || stat === 'SpA')
    return Math.round(actualStat * (2*level/5 + 2)/22);
  return actualStat;
}
function getUnadjustedStat(species, level, evsStr, nature, stat) {
  const baseStat = species.baseStats[stat.toLowerCase()];

  let ev = 0;
  if (evsStr.includes(stat)) {
    const evsStrUpToEv = evsStr.substring(0, evsStr.indexOf(stat) - 1);
    ev = parseInt(evsStrUpToEv.substring(evsStrUpToEv.lastIndexOf(' ') + 1));
  }

  if (stat === 'HP') {
    if (species.name === 'Shedinja')
    return 1;
    else
    return Math.floor((2*baseStat + 31 + Math.floor(ev/4)) * level/100) + level + 10;
  } else {
    const raisedStat = nature ? STATS[NATURES[nature][0]] : '';
    const loweredStat = nature ? STATS[NATURES[nature][1]] : '';
    let multiplier = 1;
    if (stat === raisedStat)
      multiplier += .1;
    if (stat === loweredStat)
      multiplier -= .1;
    return Math.floor((Math.floor((2*baseStat + 31 + Math.floor(ev/4)) * level/100) + 5) * multiplier);
  }
}

function spanWithType(str, type) {
  return spanWithClass(str, 'type-' + type.toLowerCase());
}
function spanWithClass(str, class_) {
  return '<span class="' + class_ + '">' + str + '</span>';
}
function spanWithTitle(str, title) {
  title = title.replaceAll('"', '&quot;')
  return '<span class="hasHoverText" title="' + title + '">' + str + '</span>';
}

function skipPokemonChoice() {
  const choicesDiv = document.getElementById('choices');
  killAllChildren(choicesDiv);
  endPokemonChoosing(null);
  document.getElementById('skip').hidden = true;
}

function choosePokemon(choicesDiv, pokemonStr) {
  const pokeDiv = getEmptyPartyDiv();
  if (!pokeDiv) {
    alert('Your party is full! You must delete a Pokemon first.');
    return;
  }

  document.getElementById('skip').hidden = true;
  
  togglePokeDiv(pokeDiv, false);
  
  pokeDiv.querySelector('.pokemon').innerText = pokemonStr + '\n-\n-\n-\n-\n';
  updatePokemonDiv(pokeDiv);
  
  killAllChildren(choicesDiv);
  
  beginAddMoveChoices(choicesDiv, pokeDiv, pokemonStr);
}
function addTeraChoice(choicesDiv, pokeDiv, typeChoices) {
  if (TYPES.every(type => typeChoices.includes(type)))
    throw new Error('Too many tera choices!');
  let type = randomElement(TYPES);
  while (typeChoices.includes(type))
    type = randomElement(TYPES);
  typeChoices.push(type);

  const teraChoiceDiv = document.createElement('div');
  teraChoiceDiv.classList.add('flex-col');

  const teraChoiceEle = document.createElement('h2');
  teraChoiceEle.classList.add('info-box', 'text-center');
  teraChoiceEle.innerHTML = spanWithType(type, type);
  const teraChoiceImg = document.createElement('img');
  teraChoiceImg.src = 'https://play.pokemonshowdown.com/sprites/types/Tera' + type + '.png';
  teraChoiceEle.append(teraChoiceImg);

  const teraChoiceButton = document.createElement('button');
  teraChoiceButton.innerText = 'choose';
  teraChoiceButton.onclick = function() {chooseTera(choicesDiv, pokeDiv, type)};

  teraChoiceDiv.append(teraChoiceEle, teraChoiceButton);
  choicesDiv.append(teraChoiceDiv);
}
function chooseTera(choicesDiv, pokeDiv, type) {
  const pokeEle = pokeDiv.querySelector('.pokemon');
  const pokemonStr = pokeEle.innerText.replace('Tera Type:', 'Tera Type: ' + type);
  pokeEle.innerHTML = pokemonInHTML(pokemonStr);

  killAllChildren(choicesDiv);

  endPokemonChoosing(pokeDiv);
}
function beginAddMoveChoices(choicesDiv, pokeDiv, pokemonStr) {
  const speciesId = getSpeciesIdOfPokemon(pokemonStr);
  const moveIds = getLearnset(speciesId);
  addMoveChoices(choicesDiv, pokeDiv, speciesId, moveIds);
}
function addMoveChoices(choicesDiv, pokeDiv, speciesId, moveIds) {
  for (let i = 0; i < numChoices(); i++)
    addMoveChoice(choicesDiv, pokeDiv, speciesId, moveIds);
}
function addMoveChoice(choicesDiv, pokeDiv, speciesId, moveIds) {
  let move;
  if (moveIds.length === 0)
    move = randomMove(false);
  else 
    move = handleHiddenPower(moves[removeRandom(moveIds)]);

  const choiceDiv = document.createElement('div');
  choiceDiv.classList.add('flex-col');

  const choiceEle = document.createElement('p');
  choiceEle.classList.add('info-box', 'move-choice');
  choiceEle.innerHTML = spanWithClass(spanWithType(move.name, move.type), 'big-text') + '\n' + moveDesc(move, move.type);

  const choiceButton = document.createElement('button');
  choiceButton.innerText = 'choose';
  choiceButton.onclick = function() {chooseMove(choicesDiv, pokeDiv, speciesId, moveIds, move)};

  choiceDiv.append(choiceEle, choiceButton);
  choicesDiv.append(choiceDiv);
}
function chooseMove(choicesDiv, pokeDiv, speciesId, moveIds, move) {
  const pokeEle = pokeDiv.querySelector('.pokemon');
  const pokemonStr = pokeEle.innerText.replace('\n-\n', '\n- ' + move.name + '\n');
  pokeEle.innerHTML = pokemonInHTML(pokemonStr);

  killAllChildren(choicesDiv);

  if (pokemonStr.includes('\n-\n')) {
    addMoveChoices(choicesDiv, pokeDiv, speciesId, moveIds);
  } else if (pokemonCanTera(pokemonStr)) {
    const typeChoices = [];
    for (let i = 0; i < numChoices(); i++)
      addTeraChoice(choicesDiv, pokeDiv, typeChoices);
  } else {
    endPokemonChoosing(pokeDiv);
  }
}

function endPokemonChoosing(pokeDiv) {
  document.getElementById('pokeball').selectedIndex = 0;
  document.getElementById('type').selectedIndex = 0;
  if (pokeDiv)
    togglePokeDiv(pokeDiv, true);
  toggleNonPokemonChoices(true);
}

function togglePokeDiv(pokeDiv, canEdit) {
  if (canEdit)
    pokeDiv.classList.remove('chosen');
  else
    pokeDiv.classList.add('chosen');
  pokeDiv.querySelector('.pokemon').setAttribute('contenteditable', canEdit);
}
function toggleNonPokemonChoices(turnOn) {
  const buttons = document.querySelectorAll('button');
  for (const button of buttons) {
    if (button.parentElement.classList.contains('item-price'))
      button.disabled = !turnOn;
  }
  document.getElementById('winRound').disabled = !turnOn;
  document.getElementById('loseRound').disabled = !turnOn;
  document.getElementById('pokeball').disabled = !turnOn;
  document.getElementById('type').disabled = !turnOn;
  document.getElementById('refresh').disabled = !turnOn;
}

function removeRandom(arr) {
  const index = randomInt(arr.length);
  const out = arr[index];
  arr.splice(index, 1);
  return out;
}

function getEmptyPartyDiv() {
  const partyDiv = document.getElementById('party');
  for (const partyPokeDiv of partyDiv.querySelectorAll('.pokemon-div')) {
    const partyPokeEle = partyPokeDiv.querySelector('.pokemon');
    if (partyPokeEle.innerText.trim() === '') {
      return partyPokeDiv;
    }
  }
  return null;
}

function getPartySpeciesIds() {
  return getPartyStrs().map(pokemonStr => getSpeciesIdOfPokemon(pokemonStr));
}
/*
* Does not include empty slots
*/
function getPartyStrs() {
  let partyStrs = [];
  const partyDiv = document.getElementById('party');
  for (const partyPokeDiv of partyDiv.querySelectorAll('.pokemon-div')) {
    const partyPokeEle = partyPokeDiv.querySelector('.pokemon');
    const pokemonStr = partyPokeDiv.innerText.trim();
    if (pokemonStr !== '')
      partyStrs.push(pokemonStr);
  }
  return partyStrs;
}

function copyParty() {
  const partyDiv = document.getElementById('party');
  let partyStr = '';
  for (const pokemonEle of partyDiv.querySelectorAll('.pokemon')) {
    const pokemonStr = pokemonEle.innerText.trim();
    if (pokemonStr !== '')
      partyStr += pokemonStr + '\n\n';
  }
  navigator.clipboard.writeText(partyStr);
}

function winRound() {
  nextRound(WIN_INCOME);
}
function loseRound() {
  nextRound(LOSE_INCOME);
}
function nextRound(income) {
  if (!pay(-1 * income)) return;

  const choicesDiv = document.getElementById('choices');
  killAllChildren(choicesDiv);
  const addChoicesSuccessful = addChoices(choicesDiv);
  if (!addChoicesSuccessful) {
    pay(income);
    return;
  }
  toggleNonPokemonChoices(false);
  
  const isPartyFull = getEmptyPartyDiv() === null;
  document.getElementById('skip').hidden = !isPartyFull;

  const refreshButton = document.getElementById('refresh');
  refreshButton.textContent = '$' + BASE_REFRESH_COST + ' - refresh';
}

function refreshShop(isViaMoney) {
  const shopDiv = document.getElementById('shop');
  const frozenItems = [];
  let numItemsToAdd = NUM_SHOP_OPTIONS;
  for (let i = 0, shopIndex = 0; i < shopDiv.childNodes.length; i++) {
    const itemDiv = shopDiv.childNodes[i];
    if (itemDiv.querySelector('.pokemon-div')) // then it's choices div, not an item div
      continue;
    shopIndex++;
    if (itemDiv.querySelector('input').checked) {
      frozenItems[i] = itemDiv;
      numItemsToAdd--;
    }
  }

  if (isViaMoney) {
    if (numItemsToAdd <= 0) {
      alert('Too many frozen items!');
      return;
    }
    const refreshButton = document.getElementById('refresh');
    const price = parseInt(refreshButton.textContent.substring(1, refreshButton.textContent.indexOf(' ')));
    if(!pay(price)) return;
    refreshButton.textContent = '$' + (price + DELTA_REFRESH_COST) + ' - refresh';
  }

  killAllChildren(shopDiv);

  for (let i = 0; i < numItemsToAdd; i++) {
    while (frozenItems[shopDiv.childNodes.length])
      shop.append(frozenItems[shopDiv.childNodes.length]);

    let item = randomElement(items);
    // item = items[3];
    while ((item.weight && !(Math.random() < item.weight))
        || (item.requiredSpecies && !getPartySpeciesIds().some(speciesId => item.requiredSpecies.includes(speciesId))))
      item = randomElement(items);
    if (Math.random() < 1/3)
      item = randomTM();

    item = structuredClone(item);
    if (item.type === 'heldItem') {
      const heldItemName = item.name;
      const desc = heldItems[getHeldItemId(item.name)].desc;
      if (Math.random() < .05 && !item.requiredSpecies) {
        item.name += ' Party';
        item.type = 'heldItemParty';
        if (item.price === 1)
          item.price = 0;
        item.price = (item.price - AVG_HELD_ITEM_VALUE) + 'n+' + AVG_HELD_ITEM_VALUE;
        item.desc = "Set EVERY Pokemon's held item to ";
      } else {
        item.desc = "Set a Pokemon's held item to ";
      }
      item.desc += heldItemName + '.\n' + spanWithClass(desc, 'attr');
    }
    shopDiv.append(createItemDiv(item));
  }
  for (let i = shopDiv.childNodes.length; i < frozenItems.length; i++) {
    if (frozenItems[i])
      shopDiv.append(frozenItems[i]);
  }
}
function getItemPrice(item) {
  let price = item.price;
  if (typeof price === 'string' && price.includes('n')) {
    // handle item prices of the form an, an+b, or an-b
    const splitByN = price.split('n');
    let a = parseInt(splitByN[0]);
    if (isNaN(a))
      a = 1;
    let b = parseInt(splitByN[1]);
    if (isNaN(b))
      b = 0;
    price = a * getPartyStrs().length + b;
  }
  return price;
}
function createItemDiv(item, isExtra) {
  const itemDiv = document.createElement('div');
  itemDiv.classList.add('flex-row', 'mt-1');

  const freezeInput = document.createElement('input');
  freezeInput.type = 'checkbox';
  freezeInput.classList.add('checkbox');
  if (isExtra)
    freezeInput.disabled = true;
  // freezeInput.hidden = true; // effectively removes freezeInput

  const itemEle = document.createElement('div');
  itemEle.classList.add('info-box', 'item');
  itemEle.innerHTML = itemInHTML(item);

  const itemPrice = getItemPrice(item);

  const itemPriceEle = document.createElement('div');
  itemPriceEle.classList.add('info-box', 'item-price', 'flex-col-centered');
  const priceEle = document.createElement('h2');
  priceEle.classList.add('mb-4px');
  priceEle.innerText = '$' + itemPrice;
  const buyButton = document.createElement('button');
  buyButton.classList.add('mb-4px');
  buyButton.onclick = function() {buyItem(itemDiv, item, itemPrice)};
  buyButton.innerText = 'buy';
  if (itemPrice < 0) {
    priceEle.classList.add('green');
    priceEle.innerText = '+$' + -1 * itemPrice;
    buyButton.innerText = 'earn';
  }
  itemPriceEle.append(priceEle, buyButton);

  itemDiv.append(freezeInput, itemEle, itemPriceEle);
  return itemDiv;
}
function itemInHTML(item) {
  return '<span class="' + item.type + ' big-text">' + item.name + '</span>'
            + '\n' + itemDescInHTML(item.desc, item.type.includes('TM'));
}
const KEYWORD_HOVER_TEXTS = {
  'held item': 'e.g. "Pikachu (F) @ Leftovers"',
  'EV': 'e.g. "EVs: 1 HP / 252 SpA"',
  'Nature': 'add a new line under EVs\ne.g. "Bold Nature"',
  'gender': 'e.g. "Pikachu (F)"'
};
function itemDescInHTML(itemDesc, isTM) {
  if (!isTM)
    for (const [keyword, hoverText] of Object.entries(KEYWORD_HOVER_TEXTS))
      itemDesc = itemDesc.replaceAll(new RegExp('\\b'+keyword+'\\b', 'g'), spanWithTitle(keyword, hoverText));

  const splitByAsterisk = itemDesc.split('*');
  itemDesc = '';
  for (let i = 0; i < splitByAsterisk.length; i++) {
    let str = splitByAsterisk[i];
    if (i % 2 == 1) {
      if (getMoveId(str))
        str = moveInHTML(str);
      else if (getHeldItemId(str))
        str = heldItemInHTML(str);
    }
    itemDesc += str;
  }
  return itemDesc;
}

function heldItemInHTML(heldItemName) {
  return spanWithTitle(heldItemName, heldItems[getHeldItemId(heldItemName)].desc);
}

function randomTM() {
  let randy = Math.random();

  if ((randy -= .2) < 0) {
    return randomUniversalTM();
  } else if ((randy -= .1) < 0) {
    const move = randomMove(true);
    return {
      name: 'Party TM #' + move.num,
      type: 'partyTM',
      price: tmPrice(move)/2 + 'n+20',
      desc: tmDesc('EVERY Pokemon MUST learn ', move),
    };
  } else if ((randy -= .2) < 0) {
    const typeMultiset = [];
    const speciesIds = getPartySpeciesIds();
    for (const speciesId of speciesIds)
      typeMultiset.push(...allSpecies[speciesId].types);
    if (TYPES.forEach(type => !typeMultiset.includes(type)))
      return randomTM(); // no valid Type TMs available, so re-roll
    if (Math.random() < .01) {
      const type = randomElement(typeMultiset);
      return {
        name: 'Perfect ' + type + ' TM',
        type: 'type-' + type.toLowerCase(),
        price: 50,
        desc: 'Teach ANY ' + type.toUpperCase() + '-TYPE Pokemon ANY ' + type.toUpperCase()
                + '-TYPE move (other than Z-Moves).', 
      };
    }
    let move;
    do {
      move = randomMove(true);
    } while (!typeMultiset.includes(move.type));
    const type = move.type;
    return {
      name: type + ' TM #' + move.num,
      type: 'type-' + type.toLowerCase(),
      price: 5 + tmPrice(move),
      desc: tmDesc('Teach ANY ' + type.toUpperCase() + '-TYPE Pokemon the move ', move),
    };
  } else {
    let possibleMoves = [];
    const pokemonStrs = getPartyStrs();
    for (const pokemonStr of pokemonStrs)
      possibleMoves.push(...getLearnset(getSpeciesIdOfPokemon(pokemonStr)));

    while (possibleMoves.length > 0) {
      const possibleMovesIndex = randomInt(possibleMoves.length);
      const moveId = possibleMoves[possibleMovesIndex];
      const move = handleHiddenPower(moves[moveId]);
      let learnerNames = [];
      for (const pokemonStr of pokemonStrs) {
        if (pokemonStr.includes('\n- ' + move.name))
          continue;
        const speciesId = getSpeciesIdOfPokemon(pokemonStr);
        const speciesName = getSpeciesNameOfPokemon(pokemonStr);
        if (getLearnset(speciesId).includes(moveId) && !learnerNames.includes(speciesName))
          learnerNames.push(speciesName);
      }
      if (learnerNames.length > 0) {
        return {
          name: 'TM #' + move.num,
          type: 'TM',
          price: tmPrice(move),
          desc: tmDesc('Teach ' + enumerateWithOr(learnerNames) + ' the move ', move),
        };
      } else {
        possibleMoves.splice(possibleMovesIndex, 1);
      }
    }
    return randomTM(); // no valid TMs available, so re-roll
  }
}
function randomUniversalTM() {
  const move = randomMove(true);
  return {
    name: 'Universal TM #' + move.num,
    type: 'universalTM',
    price: 10 + tmPrice(move),
    desc: tmDesc('Teach ANY Pokemon the move ', move),
  };
}
function tmPrice(move) { // expected to be a multiple of 10, for Party TM prices
  if (move.isZ)
    return 90;
  else if (move.isNonstandard === 'LGPE')
    return 30;
  else if (move.basePower > 75)
    return 20;
  else
    return 10;
}
function tmDesc(strBeforeMoveName, move) {
  return strBeforeMoveName + spanWithType(move.name, move.type) + '.'
          + '\n' + spanWithClass(moveDesc(move, move.type).replace('\n\n', '\n'), 'attr');
}
function randomMove(allowZMoves) {
  let move = randomProperty(moves);
  while (move.desc === "Power is equal to the base move's Z-Power." 
      || move.name.startsWith('Max') || (move.name.startsWith('G-Max') && move.basePower === 160)
      || (move.isZ && !allowZMoves))
    move = randomProperty(moves);
  return handleHiddenPower(move);
}

function handleHiddenPower(move) {
  if (move.name === 'Hidden Power') {
    let type = 'Normal';
    while (type === 'Normal' || type === 'Fairy')
      type = randomElement(TYPES);
    return moves['hiddenpower' + type.toLowerCase()];
  } else {
    return move;
  }
}

function enumerateWithOr(strArr) {
  if (strArr.length === 1)
    return strArr[0];
  if (strArr.length === 2)
    return strArr[0] + ' or ' + strArr[1];
  let out = '';
  for (let i = 0; i < strArr.length - 1; i++)
    out += strArr[i] + ', ';
  out += 'or ' + strArr[strArr.length-1];
  return out;
}

function buyItem(itemDiv, item, itemPrice) {
  if (!pay(itemPrice)) return;
  
  if (item.type === 'pokeball') {
    const pokeballEle = document.getElementById('pokeball');
    if (item.name === 'Random Ball') {
      pokeballEle.selectedIndex = randomInt(pokeballEle.options.length-1) + 1;
    } else {
      pokeballEle.value = item.name;
    }
  } else if (item.name.startsWith('Encounter Power: ')) {
    const type = item.name.split(' ')[2];
    document.getElementById('type').value = type;
  }

  const buyButton = itemDiv.querySelector('button');
  const checkmarkEle = document.createElement('h2');
  checkmarkEle.classList.add('mb-4px');
  checkmarkEle.textContent = 'âœ…';
  buyButton.insertAdjacentElement('afterend', checkmarkEle);
  buyButton.remove();

  const checkbox = itemDiv.querySelector('input');
  checkbox.checked = false;
  checkbox.classList.add('invisible');

  itemDiv.classList.add('chosen');
}

function pay(price) {
  const moneyEle = document.getElementById('money');
  let money = parseInt(moneyEle.value);
  if (isNaN(money)) {
    alert('Invalid money value!');
    return false;
  } else if (money < price) {
    alert('Not enough money!');
    return false;
  } else {
    money -= price;
    moneyEle.value = money;
    return true;
  }
}

function getPokeball() {
  return document.getElementById('pokeball').value;
}

function randomProperty(obj) {
  return obj[randomKey(obj)];
}

function randomElement(array) {
  return array[randomInt(array.length)];
}
function randomKey(obj) {
  const keys = Object.keys(obj);
  return keys[randomInt(keys.length)];
}

function randomInt(max) {
  return Math.floor(Math.random() * max); 
}

</script>

</body>
</html>
