<!DOCTYPE html>
<html>

<head>
<style>
.pokemon {
  font-family: monospace;
  background-color: whitesmoke;
  background-repeat: no-repeat;
  background-position-x: right;
  background-position-y: center;
  margin-right: 1rem;
  margin-bottom: 0rem;
}
.flex-row {
  display: flex;
  flex-direction: row;
  justify-content: left;
}
.gray {
  color: lightgray;
}
</style>
</head>

<body>

<h1>Roguelike Showdown</h1>

<button onclick="getChoices()">get choices</button>
<br>
<div id="choices"></div>


<script>

const STATS = ['HP', 'Atk', 'Def', 'SpA', 'SpD', 'Spe'];
// 1st number is index of stat raised, 2nd number is index of stat lowered
const NATURES = {Hardy: [1,1], Lonely: [1,2], Adamant: [1,3], Naughty: [1,4], Brave: [1,5], 
Bold: [2,1], Docile: [2,2], Impish: [2,3], Lax: [2,4], Relaxed: [2,5], 
Modest: [3,1], Mild: [3,2], Bashful: [3,3], Rash: [3,4], Quiet: [3,5], 
Calm: [4,1], Gentle: [4,2], Careful: [4,3], Quirky: [4,4], Sassy: [4,5], 
Timid: [5,1], Hasty: [5,2], Jolly: [5,3], Naive: [5,4], Serious: [5,5]};
const TYPES = ['Normal', 'Fire', 'Water', 'Grass', 'Electric',
  'Ice', 'Fighting', 'Poison', 'Ground', 'Flying',
  'Psychic', 'Bug', 'Rock', 'Ghost', 'Dark', 
  'Dragon', 'Steel', 'Fairy'];

const STAT_TOTAL_GOAL = 600;
const ILLEGAL_FORMES = ['Antique', 'GMax', 'Rapid-Strike-Gmax', 'Low-Key-Gmax'];
const ILLEGAL_MONS = [
  // cap Pikachus are functionally identical. if you unban these, make sure they always get Thunder, too
  'pikachuhoenn', 'pikachusinnoh', 'pikachuunova', 'pikachukalos', 'pikachualola', 'pikachupartner', 'pikachuworld',
  // functionally identical
  'magearnaoriginal',
  'pichuspikyeared', 
  'squawkabilly', 'squawkabillyyellow',
  'vivillonfancy',
  'xerneasneutral',
  'zarudedada',
  // functionally identical because of their ability
  'castformsunny', 'castformrainy', 'castformsnowy',
  'cherrimsunshine',
  'keldeoresolute',
  'wishiwashi',
  'miniormeteor',
  // identical except for weight
  'maushold',
  'dudunsparcethreesegment',
];

// for testing/studying purposes
let levelStats = '';

let pokedex;
loadPokedex();
let learnsets;
loadLearnsets();
let moves;
loadMoves();

function loadPokedex() {
  const xhttp = new XMLHttpRequest();
  xhttp.onload = function() {
    pokedex = JSON.parse(this.responseText);
  }
  xhttp.open("GET", "pokedex.json");
  xhttp.send();
}
function loadLearnsets() {
  const xhttp = new XMLHttpRequest();
  xhttp.onload = function() {
    learnsets = JSON.parse(this.responseText);
  }
  xhttp.open("GET", "learnsets.json");
  xhttp.send();
}
function loadMoves() {
  const xhttp = new XMLHttpRequest();
  xhttp.onload = function() {
    moves = JSON.parse(this.responseText);
  }
  xhttp.open("GET", "moves.json");
  xhttp.send();
}

function getChoices() {
  const choicesDiv = document.createElement('div');
  choicesDiv.classList.add('flex-row');
  document.getElementById('choices').prepend(choicesDiv);
  addRandomPokemon(choicesDiv);
  addRandomPokemon(choicesDiv);
  addRandomPokemon(choicesDiv);
  
  // // get level distribution
  // for (const pokemonId of Object.keys(pokedex)) {
  //   randomOfSpecies(pokemonId);
  // }
  // console.log(levelStats);

  // // list all formes
  // let formes = {};
  // for (const pokemonId of Object.keys(pokedex)) {
  //   if (pokedex[pokemonId].forme) {
  //     if (!formes[pokedex[pokemonId].forme])
  //       formes[pokedex[pokemonId].forme] = [];
  //     formes[pokedex[pokemonId].forme].push(pokemonId);
  //   }
  // }
  // console.log(formes);
}

function addRandomPokemon(choicesDiv) {
  let pokemonId = randomKey(pokedex);
  // pokemonId = 'genesect';
  while ((pokedex[pokemonId].forme && ILLEGAL_FORMES.includes(pokedex[pokemonId].forme)) 
            || ILLEGAL_MONS.includes(pokemonId))
    pokemonId = randomKey(pokedex);
  
  const pokemonEle = document.createElement('p');
  pokemonEle.classList.add('pokemon');
  pokemonEle.innerHTML = randomOfSpecies(pokemonId);
  pokemonEle.style.backgroundImage = getImageURL(pokemonId);
  choicesDiv.prepend(pokemonEle);
}

function getImageURL(pokemonId) {
  return 'url(https://play.pokemonshowdown.com/sprites/dex/' + pokedex[pokemonId].name.toLowerCase().replace(/\s+/g, '') + '.png)';
}

function randomOfSpecies(pokemonId) {
  const pokemon = pokedex[pokemonId];

  let out = pokemon.name;
  if (pokemon.baseSpecies === 'Arceus')
    out += ' @ ' + randomElement(pokemon.requiredItems);
  else if (pokemon.baseSpecies === 'Silvally' || pokemon.baseSpecies === 'Genesect')
    out += ' @ ' + pokemon.requiredItem;

  out += '<br>Ability: ' + randomProperty(pokemon.abilities);

  let bst = 0;
  for (const stat of STATS)
    bst += pokemon.baseStats[stat.toLowerCase()];
  const level = Math.round(100 * (STAT_TOTAL_GOAL - 10 - 5*5) / (2 * bst + 100 + 31*6));
  out += '<br>' + spanWithClass('Level: ' + level, 'gray');
  levelStats += level + ', ';

  if (pokemon.forme && (pokemon.forme.includes('Mega') || pokemon.forme === 'Primal'))
    out += '<br>' + spanWithClass('Tera Type: ' + randomElement(TYPES), 'gray');
  else
    out += '<br>Tera Type: ' + randomElement(TYPES);
    
  out += '<br>' + spanWithClass('EVs: 1 HP', 'gray');

  // add moveset
  if (pokemonId.substring(0, 8) === 'pokestar') {
    const moveset = randomElement(learnsets[pokemonId].eventData).moves;
    for (const move of moveset)
      out += '<br>- ' + moves[move].name;
  } else {
    let learnsetData = learnsets[pokemonId];

    if (!learnsetData?.learnset)
      learnsetData = learnsets[pokemon.baseSpecies.toLowerCase()];

    let possibleMoves = Object.keys(learnsetData.learnset);
    if (possibleMoves.length < 4) {
      let changesFrom;
      if (pokemon.changesFrom)
        changesFrom = pokemon.changesFrom;
      else if (pokemon.baseSpecies)
        changesFrom = pokemon.baseSpecies;
      
      if (changesFrom) {
        let baseSpeciesId = Object.keys(pokedex).find(pokemonId => pokedex[pokemonId].name === changesFrom);
        possibleMoves.push(...Object.keys(learnsets[baseSpeciesId].learnset));
      }
    }
    
    for (let i = 0; i < 4; i++) {
      if (possibleMoves.length > 0) {
        let moveIndex = randomInt(possibleMoves.length);
        if (i === 0) {
          if (pokemon.changesFrom === 'Pikachu-Cosplay')
            moveIndex = 0; // guarantee the cosplay-specific move
          else if (pokemonId === 'pikachuoriginal')
            moveIndex = possibleMoves.indexOf('thunderbolt');
        }
        out += '<br>- ' + moves[possibleMoves[moveIndex]].name;
        possibleMoves.splice(moveIndex, 1);
      } else {
        out += '<br>';
      }
    }
  }

  out += '<br><br>STATS: '
  for (const stat of STATS) {
    let statNum;
    if (stat === 'HP') {
      if (pokemonId === 'shedinja')
        statNum = 1;
      else
        statNum = Math.floor((2*pokemon.baseStats[stat.toLowerCase()] + 31) * level/100) + level + 10;
    } else {
      statNum = Math.floor((2*pokemon.baseStats[stat.toLowerCase()] + 31) * level/100) + 5;
    }
    out += nSpaces(3 - (statNum + '').length) + statNum + ' ' + stat + ' / ';
    if (stat === 'Def')
      out += '<br>' + nSpaces('STATS: ... HP /'.length);
  }
  out = out.slice(0, -2);

  return out;
}

function spanWithClass(str, class_) {
  return '<span class="' + class_ + '">' + str + '</span>';
}

function nSpaces(n) {
  let out = '';
  for (let i = 0; i < n; i++)
    out += '&nbsp';
  return out;
}

function randomProperty(obj) {
  return obj[randomKey(obj)];
}

function randomElement(array) {
  return array[randomInt(array.length)];
}
function randomKey(obj) {
  const keys = Object.keys(obj);
  return keys[randomInt(keys.length)];
}

function randomInt(max) {
  return Math.floor(Math.random() * max); 
}

</script>

</body>
</html>
