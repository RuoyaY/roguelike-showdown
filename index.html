<!DOCTYPE html>
<html>

<head>
<style>
body {
  background-color: darkslateblue;
  color: white;
}

.pokemon {
  font-family: monospace;
  background-color: black;
  background-repeat: no-repeat;
  background-position-x: right;
  background-position-y: center;
  padding: 2px;
  margin: 0px;
  border-radius: 4px;
  /* border-top-right-radius: 1px; */
  position: relative;
  white-space: pre;
}
.flex-row {
  display: flex;
  flex-direction: row;
  justify-content: left;
}
.flex-column {
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.overlay {
  position: absolute;
  top: 0;
  right: 0;
}
.overlay > img {
  margin-left: 1px;
  margin-top: -1px;
}

.m-2px {
  margin: 2px;
}
.ml-4px {
  margin-left: 4px;
}

h2 {
  margin-top: 8px;
  margin-bottom: 8px;
  text-align: center;
}
textarea {
  white-space: pre;
}
button:focus {
  box-shadow: 0 0 0 2px rgba(0,0,0,.5);
}

.gray {
  color: #444;
}

.hasHoverText {
  text-decoration: dashed underline; 
}

.type-normal { color: #A8A878 }
.type-fighting { color: #C03028 }
.type-flying { color: #A890F0 }
.type-poison { color: #A040A0 }
.type-ground { color: #E0C068 }
.type-rock { color: #B8A038 }
.type-bug { color: #A8B820 }
.type-ghost { color: #705898 }
.type-steel { color: #B8B8D0 }
.type-fire { color: #F08030 }
.type-water { color: #6890F0 }
.type-grass { color: #78C850 }
.type-electric { color: #F8D030 }
.type-psychic { color: #F85888 }
.type-ice { color: #98D8D8 }
.type-dragon { color: #7038F8 }
.type-dark { color: #705848 }
.type-fairy { color: #EE99AC }

.attr { color: #A0A0A0 }

.stat-hp { color: #FF0000 }
.stat-atk { color: #F08030 }
.stat-def { color: #F8D030 }
.stat-spa { color: #6890F0 }
.stat-spd { color: #78C850 }
.stat-spe { color: #F85888 }
</style>
</head>

<body>

<div class="flex-row">
  <div>
    <h1>Roguelike Showdown</h1>
    <label for="money">$</label> <input id="money" type="number" value="0">
    <hr>
    <div class="flex-row">
      <input id="species" placeholder="get a specific species">
      <button class="ml-4px" onclick="getChoices()">get choices</button>
    </div>
    <br>
    <p id="speciesError" style="display:none">ERROR: species name not recognized</p>
    <div id="choices"></div>
  </div>
  <div class="ml-4px">
    <h2>Party <button onclick="copyParty()" class="clipboard-button">ðŸ“‹</button></h2>
    <textarea id="partyTextarea" rows="52"></textarea>
  </div>
  <div class="ml-4px">
    <h2>Box</h2>
    <textarea id="boxTextarea" rows="52"></textarea>
  </div>
</div>


<script>

const STATS = ['HP', 'Atk', 'Def', 'SpA', 'SpD', 'Spe'];
// 1st number is index of stat raised, 2nd number is index of stat lowered
const NATURES = {Hardy: [1,1], Lonely: [1,2], Adamant: [1,3], Naughty: [1,4], Brave: [1,5], 
Bold: [2,1], Docile: [2,2], Impish: [2,3], Lax: [2,4], Relaxed: [2,5], 
Modest: [3,1], Mild: [3,2], Bashful: [3,3], Rash: [3,4], Quiet: [3,5], 
Calm: [4,1], Gentle: [4,2], Careful: [4,3], Quirky: [4,4], Sassy: [4,5], 
Timid: [5,1], Hasty: [5,2], Jolly: [5,3], Naive: [5,4], Serious: [5,5]};
const TYPES = ['Normal', 'Fire', 'Water', 'Grass', 'Electric',
  'Ice', 'Fighting', 'Poison', 'Ground', 'Flying',
  'Psychic', 'Bug', 'Rock', 'Ghost', 'Dark', 
  'Dragon', 'Steel', 'Fairy'];

const STAT_TOTAL_GOAL = 600;
const ILLEGAL_FORMES = ['Antique', 'Gmax', 'Rapid-Strike-Gmax', 'Low-Key-Gmax'];
const ILLEGAL_MONS = [
  // cap Pikachus are functionally identical. if you unban these, make sure they always get Thunder, too
  'pikachuhoenn', 'pikachusinnoh', 'pikachuunova', 'pikachukalos', 'pikachualola', 'pikachupartner', 'pikachuworld',
  // functionally identical
  'magearnaoriginal',
  'pichuspikyeared', 
  'squawkabilly', 'squawkabillyyellow',
  'vivillonfancy',
  'xerneasneutral',
  'zarudedada',
  // functionally identical because of their ability
  'castformsunny', 'castformrainy', 'castformsnowy',
  'cherrimsunshine',
  'keldeoresolute',
  'wishiwashi',
  'miniormeteor',
  // identical except for weight
  'maushold',
  'dudunsparcethreesegment',
];

// for testing/studying purposes
let levelStats = '';

let pokedex;
loadPokedex();
let learnsets;
loadLearnsets();
let moves;
loadMoves();
let abilities;
loadAbilities();

function loadPokedex() {
  const xhttp = new XMLHttpRequest();
  xhttp.onload = function() {
    pokedex = JSON.parse(this.responseText);
  }
  xhttp.open("GET", "pokedex.json");
  xhttp.send();
}
function loadLearnsets() {
  const xhttp = new XMLHttpRequest();
  xhttp.onload = function() {
    learnsets = JSON.parse(this.responseText);
  }
  xhttp.open("GET", "learnsets.json");
  xhttp.send();
}
function loadMoves() {
  const xhttp = new XMLHttpRequest();
  xhttp.onload = function() {
    moves = JSON.parse(this.responseText);
  }
  xhttp.open("GET", "moves.json");
  xhttp.send();
}
function loadAbilities() {
  const xhttp = new XMLHttpRequest();
  xhttp.onload = function() {
    abilities = JSON.parse(this.responseText);
  }
  xhttp.open("GET", "abilities.json");
  xhttp.send();
}

function getPokemonId(pokemonName) {
  return Object.keys(pokedex).find(pokemonId => pokedex[pokemonId].name === pokemonName 
    || pokedex[pokemonId].cosmeticFormes?.includes(pokemonName));
}
function getMoveId(moveName) {
  return Object.keys(moves).find(moveId => moves[moveId].name === moveName);
}
function getAbilityId(abilityName) {
  return Object.keys(abilities).find(abilityId => abilities[abilityId].name === abilityName);
}

function getChoices() {
  const choicesDiv = document.createElement('div');
  choicesDiv.classList.add('flex-row');
  document.getElementById('choices').prepend(choicesDiv);
  
  const speciesName = document.getElementById('species').value.trim();
  if (speciesName === '') {
    addRandomPokemon(choicesDiv);
    addRandomPokemon(choicesDiv);
  } else {
    addRandomPokemon(choicesDiv, speciesName);
  }
  
  // get level distribution
  // for (const pokemonId of Object.keys(pokedex)) {
  //   randomOfSpecies(pokemonId);
  // }
  // console.log(levelStats);

  // // list all formes
  // let formes = {};
  // for (const pokemonId of Object.keys(pokedex)) {
  //   if (pokedex[pokemonId].forme) {
  //     if (!formes[pokedex[pokemonId].forme])
  //       formes[pokedex[pokemonId].forme] = [];
  //     formes[pokedex[pokemonId].forme].push(pokemonId);
  //   }
  // }
  // console.log(formes);
}

function addRandomPokemon(choicesDiv, speciesName) {  
  if (!speciesName) {
    let pokemonId = randomKey(pokedex);
    let pokemon = pokedex[pokemonId];
    while ((pokemon.forme && ILLEGAL_FORMES.includes(pokemon.forme)) 
              || ILLEGAL_MONS.includes(pokemonId)) {
      pokemonId = randomKey(pokedex);
      pokemon = pokedex[pokemonId];
    }

    speciesName = pokemon.name;

    if (pokemon.cosmeticFormes && !isPokestar(pokemonId)) {
      const randy = randomInt(pokemon.cosmeticFormes.length + 1);
      if (randy < pokemon.cosmeticFormes.length)
        speciesName = pokemon.cosmeticFormes[randy];
    }
  }
  
  const speciesErrorEle = document.getElementById('speciesError');
  if (!getPokemonId(speciesName)) {
    speciesErrorEle.style.display = 'initial';
    return;
  } else {
    speciesErrorEle.style.display = 'none';
  }
  
  const divEle = document.createElement('div');
  divEle.classList.add('flex-column', 'm-2px');
  const pokemonEle = document.createElement('p');
  pokemonEle.classList.add('pokemon');
  pokemonEle.innerHTML = pokemonInHTML(randomOfSpecies(speciesName));
  pokemonEle.style.backgroundImage = getImageURL(speciesName);
  divEle.append(pokemonEle);
  const buttonEle = document.createElement('button');
  buttonEle.textContent = 'choose';
  buttonEle.onclick = function() {choosePokemon(buttonEle)};
  divEle.append(buttonEle);
  choicesDiv.append(divEle);
}

function isPokestar(pokemonId) {
  return pokemonId.startsWith('pokestar');
}

function getImageURL(speciesName) {
  return 'url(https://play.pokemonshowdown.com/sprites/gen5/' + speciesName.toLowerCase().replace(/\s+/g, '') + '.png)';
}

function randomOfSpecies(speciesName) {
  const pokemonId = getPokemonId(speciesName);
  const pokemon = pokedex[pokemonId];

  let displayName = speciesName;
  let gender;
  let heldItem;

  if (pokemon.gender)
    gender = pokemon.gender;
  else {
    let probMale = .5;
    if (pokemon.genderRatio)
      probMale = pokemon.genderRatio.M;
    gender = Math.random() < probMale ? 'M' : 'F';
  }

  if (pokemon.baseSpecies === 'Arceus') {
    displayName = pokemon.baseSpecies;
    heldItem = randomElement(pokemon.requiredItems);
  }
  else if (pokemon.baseSpecies === 'Silvally' || pokemon.baseSpecies === 'Genesect') {
    displayName = pokemon.baseSpecies;
    heldItem = pokemon.requiredItem;
  }

  let out = displayName;
  if (gender !== 'N')
    out += ' (' + gender + ')';
  if (heldItem)
    out += ' @ ' + heldItem;

  const abilityName = randomProperty(pokemon.abilities);
  out += '\nAbility: ';
  if (abilityName)
   out += abilityName;

  let bst = 0;
  for (const stat of STATS)
    bst += pokemon.baseStats[stat.toLowerCase()];
  let level = Math.round(100 * (STAT_TOTAL_GOAL - 10 - 5*5) / (2 * bst + 100 + 31*6));
  if (pokemonId === 'pokestarspirit')
    level = 1;
  out += '\nLevel: ' + level;
  levelStats += level + ', ';

  if (pokemon.forme && (pokemon.forme.includes('Mega') || pokemon.forme === 'Primal' || pokemon.forme === 'Ultra'))
    out += '\n';
  else {
    out += '\nTera Type: ' + randomElement(TYPES);
  }
    
  out += '\nEVs: 1 HP';

  // add moveset
  if (isPokestar(pokemonId)) {
    const moveset = randomElement(learnsets[pokemonId].eventData).moves;
    for (const moveId of moveset)
      out += '\n- ' + addHiddenPowerType(moves[moveId].name);
  } else {
    let learnsetData = learnsets[pokemonId];

    if (!learnsetData?.learnset)
      learnsetData = learnsets[pokemon.baseSpecies.toLowerCase()];

    let possibleMoves = Object.keys(learnsetData.learnset);
    if (possibleMoves.length < 4) {
      let changesFrom;
      if (pokemon.changesFrom)
        changesFrom = pokemon.changesFrom;
      else if (pokemon.baseSpecies)
        changesFrom = pokemon.baseSpecies;
      
      if (changesFrom) {
        let baseSpeciesId = getPokemonId(changesFrom);
        possibleMoves.push(...Object.keys(learnsets[baseSpeciesId].learnset));
      }
    }
    
    for (let i = 0; i < 4; i++) {
      if (possibleMoves.length > 0) {
        const moveIndex = randomInt(possibleMoves.length);
        const moveId = possibleMoves[moveIndex];
        out += '\n- ' + addHiddenPowerType(moves[moveId].name);
        possibleMoves.splice(moveIndex, 1);
      } else {
        out += '\n';
      }
    }
  }

  out += '\n\n'
  for (const stat of STATS) {
    let statNum;
    if (stat === 'HP') {
      if (pokemonId === 'shedinja')
        statNum = 1;
      else
        statNum = Math.floor((2*pokemon.baseStats[stat.toLowerCase()] + 31) * level/100) + level + 10;
    } else {
      statNum = Math.floor((2*pokemon.baseStats[stat.toLowerCase()] + 31) * level/100) + 5;
    }
    out += spanWithClass((statNum + ' ').padStart(4) + stat, 'stat-' + stat.toLowerCase()) + ' ';
    if (stat === 'Def')
      out += '\n' + ' '.repeat('... HP '.length);
  }
  out = out.slice(0, -1);

  out += '<div class="overlay">';
  out += '<img src="https://play.pokemonshowdown.com/sprites/types/' + pokemon.types[0] + '.png">';
  if (pokemon.types[1])
    out += '<img src="https://play.pokemonshowdown.com/sprites/types/' + pokemon.types[1] + '.png">';
  out += '</div>';

  return out;
}

function getSpeciesId(pokemonStr) {
  getPokemonId(pokemonStr.substring(0, pokemonStr.indexOf(' ')));
}

function pokemonInHTML(pokemonStr) {
  const pokemonLines = pokemonStr.split('\n');
  out = '';

  const speciesId = getSpeciesId(pokemonLines[0]);
  const species = pokedex[speciesId];

  for (const pokemonLine of pokemonLines) {
    if (pokemonLine.startsWith('Ability: ')) {
      const abilityName = pokemonLine.substring('Ability: '.length);
      out += spanWithClass('Ability: ', 'attr');
      out += spanWithTitle(abilityName, abilities[getAbilityId(abilityName)].shortDesc);

    } else if (pokemonLine.startsWith('Level: ')) {
      out += spanWithClass(pokemonLine, 'gray');
      
    } else if (pokemonLine.startsWith('Tera Type: ')) {
      const teraType = pokemonLine.substring('Tera Type: '.length);
      out += spanWithClass('Tera Type: ', 'attr');
      out += spanWithClass(teraType, 'type-' + teraType.toLowerCase());

    } else if (pokemonLine.startsWith('EVs: ')) {
      out += spanWithClass(pokemonLine, 'gray');

    } else if (pokemonLine.startsWith('- ')) {
      const moveName = pokemonLine.substring('- '.length);

      let moveId, move, type;
      if (moveName.startsWith('Hidden Power')) {
        moveId = 'hiddenpower';
        move = moves[moveId];
        type = moveName.substring(moveName.indexOf('['), moveName.indexOf(']'));
      } else {
        moveId = getMoveId(moveName);
        move = moves[moveId];
        type = move.type;
      }

      let title = 'Type: ' + type + '\nCat: ' + move.category;
      if (move.basePower && move.basePower !== 0)
        title += '\nPow: ' + move.basePower;
      if (move.accuracy && move.accuracy !== true)
        title += '\nAcc: ' + move.accuracy;
      title += '\n\n' + move.shortDesc;

      out += spanWithClass('- ' + spanWithTitle(moveName, title), 'type-' + type.toLowerCase());

    } else {
      out += pokemonLine;
    }
    out += '\n';
  }

  return out;
}

function spanWithClass(str, class_) {
  return '<span class="' + class_ + '">' + str + '</span>';
}
function spanWithTitle(str, title) {
  return '<span class="hasHoverText" title="' + title + '">' + str + '</span>';
}

function choosePokemon(buttonEle) {
  const divEle = buttonEle.parentElement;
  const pokemonEle = divEle.childNodes[0];
  const pokemonText = pokemonEle.textContent.substring(0, pokemonEle.textContent.indexOf('\n\n')) + '\n\n';
  const partyTextarea = document.getElementById('partyTextarea');
  if (partyTextarea.value.trim().split('\n\n').length < 6) 
    partyTextarea.value = pokemonText + partyTextarea.value.trimStart();
  else {
    const boxTextarea = document.getElementById('boxTextarea');
    boxTextarea.value = pokemonText + boxTextarea.value.trimStart();
  }

  for (const divInRow of divEle.parentElement.childNodes) {
    divInRow.removeChild(divInRow.childNodes[1]);
  }
}

function copyParty() {
  const partyTextarea = document.getElementById('partyTextarea');
  navigator.clipboard.writeText(partyTextarea.value);
}

function addHiddenPowerType(moveName) {
  if (moveName === 'Hidden Power') {
    let type = randomElement(TYPES);
    while (type === 'Normal' || type === 'Fairy')
      type = randomElement(TYPES);
    moveName += ' [' + type + ']';
  }
  return moveName;
}

function randomProperty(obj) {
  return obj[randomKey(obj)];
}

function randomElement(array) {
  return array[randomInt(array.length)];
}
function randomKey(obj) {
  const keys = Object.keys(obj);
  return keys[randomInt(keys.length)];
}

function randomInt(max) {
  return Math.floor(Math.random() * max); 
}

</script>

</body>
</html>
