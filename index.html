<!DOCTYPE html>
<html>

<head>

<title>Roguelike Showdown</title>
<link rel="icon" type="image/x-icon" href="favicon.ico">

<style>
body {
  background-color: black;
  color: white;
  font-family: monospace;
}
p {
  margin-top: .5em;
  margin-bottom: .5em;
}

.info-box {
  border: 1px solid;
  border-color: inherit;
  border-radius: 6px;
  border-top-right-radius: 0;
  border-top-left-radius: 0;
  padding: 6px;
  margin: 0px;
  white-space: pre-wrap;
  overflow: auto;
}
.pokemon {
  background-repeat: no-repeat;
  background-position-x: right;
  background-position-y: bottom;
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
  white-space: pre;
  padding-top: 16px;
  min-height: 10rem;
}
.tera-choice, .move-choice, .pokemon {
  width: 31ch;
}
.tera-choice {
  height: 65px;
}
.key-items {
  white-space: pre;
  width: min-content;
  min-width: 25ch;
  min-height: 1rem;
}
.editable {
  box-shadow: inset 0 0 10px white;
}
.no-move-height {
  min-height: 5rem;
}
.chosen>.editable {
  box-shadow: inset 0 0 10px lightgreen;
}
.stats {
  border-top: none;
  border-top-left-radius: 0;
  border-top-right-radius: 0;
  margin-bottom: 2px;
  width: 31ch;
  height: 3rem;
}
.item {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
.item, .pokeball-desc {
  width: 60ch;
}
.item-price {
  border-left: none;
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
  width: 7ch;
  overflow: visible;
}

.party-width {
  width: 66ch;
}

input[type=checkbox]:checked+.item, input[type=checkbox]:checked+.item+.item-price {
  background: linear-gradient(lightblue -20%,black,black,lightblue 120%);
}

.flex-row {
  display: flex;
  flex-direction: row;
  justify-content: left;
}
.flex-col-centered {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.equalWidth {
  flex-grow: 1;
  flex-basis: 0;
}

.pokemon-div, .flex-col {
  display: flex;
  flex-direction: column;
  justify-content: center;
  position: relative;
  margin: 2px;
  height: min-content;
}
.chosen {
  border-color: lightgreen;
}

.overlay {
  position: absolute;
  top: 0;
  right: 0;
  z-index: 1;
}

.types {
  width: max-content; /* only relevant to randomTransformer */
}
.types > img, .tera-type > img {
  margin-left: 1px;
  margin-right: 1px;
}

.matchups {
  background-color: rgba(0,0,0,.8);
  position: absolute;
  right: 0;
  width: max-content;

  visibility: hidden;
  /* opacity: 0;
  transition: opacity .3s; */
}
.position-left {
  left: 0;
  right: unset;
}
.ml-body {
  margin-left: 8px;
}
.types:hover .matchups, .tera-type:hover .matchups {
  visibility: visible;
  /* opacity: 1; */
}

.text-aligned-img {
  vertical-align: middle;
}

.generated-species-row {
  /* max-width: 70ch;
  overflow-x: auto; */
}

.w-min-content {
  width: min-content;
}

/* .win-counter {
  text-align: center;
} */

.true-mirror {
  font-style: italic;
}

.mr-half {
  margin-right: 0.5em;
}
.ml-1 {
  margin-left: 1rem;
}
.mb-1 {
  margin-bottom: 1rem;
}
.mt-1 {
  margin-top: 1rem;
}
.mb-4px {
  margin-top: 0px;
  margin-bottom: 4px;
}
.m-0 {
  margin: 0;
}

.checkbox {
  margin: 8px;
}

.text-center {
  text-align: center;
}

.flex-center {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.keep-newlines {
  white-space: pre-wrap;
}

.invisible {
  visibility: hidden;
}

button:focus {
  box-shadow: 0 0 0 2px rgba(255,255,255,.5);
}

.gray {
  color: #666;
}
.green {
  color: lightgreen;
}
.win-color {
  color: gold;
}
.warning {
  font-style: italic;
}
.command {
  background-color: #555;
}

.hasHoverText {
  text-decoration-line: underline;
  text-decoration-style: dashed; 
}
.strikethrough {
  text-decoration: line-through;
  text-decoration-thickness: 2px;
}

.big-text {
  font-size: large;
  font-weight: 700;
}
.improvedAbility, .improvedItem, .improvedMove {
  background-color: rgba(0,255,0,.3);
}
.worsened {
  background-color: rgba(255,0,0,.3);
}
.abilityUnexpected {
  font-style: italic;
}

.misc { color: lightgray }
.partyMisc { background: linear-gradient(45deg, hotpink, lightgray, hotpink); }
.pokeball { background: linear-gradient(0deg, white 50%, lightcoral 50%); }
.beforeBattle { color:pink }
.nextBattle { color: tomato }
.heldItem { color: orange }
.heldItemParty { background: linear-gradient(45deg, hotpink, orange, hotpink); }
.beforeHeldItem { background: linear-gradient(45deg, pink, orange, pink); }
.nextHeldItem { background: linear-gradient(45deg, tomato, orange, tomato); }
.keyItem { color: gold }
.speciesTM { color: yellow }
.partyTM { background: linear-gradient(45deg, hotpink, yellow, hotpink); }
.universalTM { background: linear-gradient(45deg, rgba(255,116,0,1) 0%, rgba(255,200,0,1) 20%, yellow 50%, rgba(210,255,0,1) 80%, rgba(99,253,245,1) 100%); }
.beforeTM { background: linear-gradient(45deg, pink, yellow, pink); }
.TMAndZCrystal { background: linear-gradient(45deg, yellow, orange); } 
.abilitizer { color: lightgreen }
.partyAbilitizer { background: linear-gradient(45deg, hotpink, lightgreen, hotpink); }
.beforeAbilitizer { background: linear-gradient(45deg, pink, lightgreen, pink); }
.nextAbilitizer { background: linear-gradient(45deg, tomato, lightgreen, tomato); }
.egg { color: wheat }
.transformer { color: violet }
.partyMisc, .pokeball, .heldItemParty, .beforeHeldItem, .nextHeldItem, .partyTM, .universalTM, .beforeTM, .TMAndZCrystal, .partyAbilitizer, .beforeAbilitizer, .nextAbilitizer {  
  background-clip: text;
  -webkit-background-clip: text;
  color: transparent;
}

.type-normal { color: #A8A878 }
.type-fighting { color: #C03028 }
.type-flying { color: #A890F0 }
.type-poison { color: #A040A0 }
.type-ground { color: #E0C068 }
.type-rock { color: #B8A038 }
.type-bug { color: #A8B820 }
.type-ghost { color: #705898 }
.type-steel { color: #B8B8D0 }
.type-fire { color: #F08030 }
.type-water { color: #6890F0 }
.type-grass { color: #78C850 }
.type-electric { color: #F8D030 }
.type-psychic { color: #F85888 }
.type-ice { color: #98D8D8 }
.type-dragon { color: #7038F8 }
.type-dark { color: #705848 }
.type-fairy { color: #EE99AC }
.type-stellar { color: #48c9b0 }

.attr { color: #A0A0A0 }

.stat-hp { color: #FF0000 }
.stat-atk { color: #F08030 }
.stat-def { color: #F8D030 }
.stat-spa { color: #6890F0 }
.stat-spd { color: #78C850 }
.stat-spe { color: #F85888 }
</style>
</head>

<body>

<div class="flex-row">
  <div>
    <h1>Roguelike Showdown</h1>

    <div hidden>
    <input type="checkbox" id="hasCrowns" checked>
    <label for="hasCrowns">Add crowns</label>
    <button onclick="copyBingoJSON()">copy bingo JSON</button>
    <br class="mb-4px">
    </div>

    <button id="save" onclick="save()">save</button>
    <button id="load" onclick="load()">load</button>
    <hr>
    Round <span id="roundCounter">0</span> of <input id="numRounds" type="number" size="3" class="mb-4px">
    <input type="checkbox" id="endless">
    <label for="endless" class="hasHoverText" title="Keeps the final round at least 1 round away, so you never reach it.">Endless</label>
    <br>
    <input type="checkbox" id="camomons">
    <label for="camomons" class="hasHoverText" title="Pokemon instead have the type(s) of their first 2 moves (revealed on entry).">Camomons</label>
    <span id="camomonsCommand" class="command">/challenge gen9customgame @@@ Camomons Mod</span>
    <br>

    <div hidden>
    <input type="checkbox" id="bossBattle">
    <label for="bossBattle" class="hasHoverText" title="Your 1st Pokemon gets level-ups and a move slot every round you get new Pokemon. Your other Pokemon are Lv1.">Boss</label>
    <input type="checkbox" id="vsBossBattle">
    <label for="vsBossBattle" class="hasHoverText" title="Check this box if you're against a Boss (certain items won't appear).">Vs Boss</label>
    <span id="bossLevelUps" class="attr"></span>
    </div>

    <h2 class="attr">Start Round</h2>
    <span id="guaranteedTypeDiv">
      <label id="guaranteedTypeLabel" for="type">Guaranteed Type:</label>
      <select id="type" class="mb-4px">
        <option></option>
        <option>Normal</option>
        <option>Fire</option>
        <option>Water</option>
        <option>Grass</option>
        <option>Electric</option>
        <option>Ice</option>
        <option>Fighting</option>
        <option>Poison</option>
        <option>Ground</option>
        <option>Flying</option>
        <option>Psychic</option>
        <option>Bug</option>
        <option>Rock</option>
        <option>Ghost</option>
        <option>Dark</option>
        <option>Dragon</option>
        <option>Steel</option>
        <option>Fairy</option>
      </select>
    </span>
    <span id="pokeballDiv">
      <label for="pokeball">Ball:</label>
      <select id="pokeball" class="mb-4px">
        <option>Pok√© Ball</option>
        <option>Great Ball</option>
        <option>Ultra Ball</option>
        <option>Nest Ball</option>
        <option>Quick Ball</option>
        <option>Moon Ball</option>
        <option>Dream Ball</option>
        <option>Friend Ball</option>
        <option>Love Ball</option>
        <option>Truant Ball</option>
        <option>Wonder Ball</option>
        <option>Strange Ball</option>
        <option>Repeat Ball</option>
        <option>Snag Ball</option>
        <option>Master Ball</option>
        <option>Normal-Type Ball</option>
        <option>Fire-Type Ball</option>
        <option>Water-Type Ball</option>
        <option>Grass-Type Ball</option>
        <option>Electric-Type Ball</option>
        <option>Ice-Type Ball</option>
        <option>Fighting-Type Ball</option>
        <option>Poison-Type Ball</option>
        <option>Ground-Type Ball</option>
        <option>Flying-Type Ball</option>
        <option>Psychic-Type Ball</option>
        <option>Bug-Type Ball</option>
        <option>Rock-Type Ball</option>
        <option>Ghost-Type Ball</option>
        <option>Dark-Type Ball</option>
        <option>Dragon-Type Ball</option>
        <option>Steel-Type Ball</option>
        <option>Fairy-Type Ball</option>
      </select>
      <br>
      <p id="pokeballDesc" class="pokeball-desc attr mb-4px"></p>
    </span>
    <input type="checkbox" id="extraIncome">
    <label for="extraIncome" id="extraIncomeLabel" class="hasHoverText">Used a money-making move</label>
    <br>
    <input type="checkbox" id="won">
    <label for="won" id="wonLabel" class="win-color">Won!</label>
    <br class="mb-4px">
    <button id="nextRound" onclick="nextRound()" class="mb-4px">start round</button>
    <div class="w-min-content">
      <div id="choices" class="flex-row"></div>
      <div class="flex-col-centered">
        <button id="skip" onclick="skipPokemonChoice()">skip</button>
      </div>
    </div>

    <h2 class="attr">Shop</h2>
    <label for="tmSeeker">Find TMs and species changes for: </label>
    <select id="tmSeeker" class="mb-4px"></select>
    <br>
    <label for="money">$</label> <input id="money" type="number">
    <button onclick="refreshShop(true)" id="refresh" class="mb-4px">refresh</button>
    <div id="taxDiv" class="attr">
      Next round, you'll lose $<span id="tax">0</span> in wealth tax.
    </div>
    <div id="shop"></div>

  </div>

  <div class="ml-1">
    <div id="beforeBattleDiv" class="party-width" hidden>
      <h2>
        <span class="beforeBattle hasHoverText" title="Revealed after both players are ready for battle.">Before Battle</span>
        üìù
      </h2>
      <div id="beforeBattle" class="keep-newlines"></div>
    </div>
    <div id="nextBattleDiv" class="party-width" hidden>
      <h2>
        <span class="nextBattle hasHoverText" title="Revealed after both players are ready for battle. Cannot be used on the final battle.">Next Battle Only</span>
        ‚öîÔ∏è 
      </h2>
      <div id="nextBattle" class="keep-newlines"></div>
    </div>

    <h2 class="attr">Party <button onclick="copyParty()" title="Copy party to clipboard">üìã</button></h2>
    <div id="party">
      <div class="flex-row">
        <div class="pokemon-div"></div>
        <div class="pokemon-div"></div>
      </div>
      <div class="flex-row">
        <div class="pokemon-div"></div>
        <div class="pokemon-div"></div>
      </div>
    </div>
    <button onclick="addPartySlot(true)" title="Add a slot">+</button>
    <button onclick="losePartySlot()" title="Remove a slot">-</button>

    <div id="keyItemsDiv" class="party-width" hidden>
      <h2 class="attr">Key Items</h2>
      <p id="keyItems" class="info-box key-items editable mb-1" contenteditable="true" spellcheck="false"></p>
    </div>
    <p id="winCounter" class="win-counter win-color"></p>
  </div>
</div>

<h2 class="attr">Generate a Pokemon</h2>
<div class="mb-1">
  <label for="speciesInput">Species: </label><input id="speciesInput" class="mb-4px">
  <label for="abilityInput">Ability: </label><input id="abilityInput" class="mb-4px">
  <button onclick="generateSpecificSpecies()">generate</button>
</div>
<p id="speciesError"></p>
<div id="species" class=""></div>


<script>

const STATS = ['HP', 'Atk', 'Def', 'SpA', 'SpD', 'Spe'];
const POWER_ITEMS = ['Power Weight', 'Power Bracer', 'Power Belt', 'Power Lens', 'Power Band', 'Power Anklet'];
const POWER_ITEM_DELTA = 100;
// 1st number is index of stat raised, 2nd number is index of stat lowered
const NATURES = {Hardy: [1,1], Lonely: [1,2], Adamant: [1,3], Naughty: [1,4], Brave: [1,5], 
Bold: [2,1], Docile: [2,2], Impish: [2,3], Lax: [2,4], Relaxed: [2,5], 
Modest: [3,1], Mild: [3,2], Bashful: [3,3], Rash: [3,4], Quiet: [3,5], 
Calm: [4,1], Gentle: [4,2], Careful: [4,3], Quirky: [4,4], Sassy: [4,5], 
Timid: [5,1], Hasty: [5,2], Jolly: [5,3], Naive: [5,4], Serious: [5,5]};
const TYPES = ['Normal', 'Fire', 'Water', 'Grass', 'Electric',
  'Ice', 'Fighting', 'Poison', 'Ground', 'Flying',
  'Psychic', 'Bug', 'Rock', 'Ghost', 'Dark', 
  'Dragon', 'Steel', 'Fairy'];
const TERA_TYPES = ['Normal', 'Fire', 'Water', 'Grass', 'Electric',
  'Ice', 'Fighting', 'Poison', 'Ground', 'Flying',
  'Psychic', 'Bug', 'Rock', 'Ghost', 'Dark', 
  'Dragon', 'Steel', 'Fairy', 'Stellar'];
// x: attacker index, y: defender index
const TYPE_MATCHUPS = [
[ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,.5, 0, 1, 1,.5, 1,],
[ 1,.5,.5, 2, 1, 2, 1, 1, 1, 1, 1, 2,.5, 1, 1,.5, 2, 1,],
[ 1, 2,.5,.5, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1,.5, 1, 1,],
[ 1,.5, 2,.5, 1, 1, 1,.5, 2,.5, 1,.5, 2, 1, 1,.5,.5, 1,],
[ 1, 1, 2,.5,.5, 1, 1, 1, 0, 2, 1, 1, 1, 1, 1,.5, 1, 1,],
[ 1,.5,.5, 2, 1,.5, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2,.5, 1,],
[ 2, 1, 1, 1, 1, 2, 1,.5, 1,.5,.5,.5, 2, 0, 2, 1, 2,.5,],
[ 1, 1, 1, 2, 1, 1, 1,.5,.5, 1, 1, 1,.5,.5, 1, 1, 0, 2,],
[ 1, 2, 1,.5, 2, 1, 1, 2, 1, 0, 1,.5, 2, 1, 1, 1, 2, 1,],
[ 1, 1, 1, 2,.5, 1, 2, 1, 1, 1, 1, 2,.5, 1, 1, 1,.5, 1,],
[ 1, 1, 1, 1, 1, 1, 2, 2, 1, 1,.5, 1, 1, 1, 0, 1,.5, 1,],
[ 1,.5, 1, 2, 1, 1,.5,.5, 1,.5, 2, 1, 1,.5, 2, 1,.5,.5,],
[ 1, 2, 1, 1, 1, 2,.5, 1,.5, 2, 1, 2, 1, 1, 1, 1,.5, 1,],
[ 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2,.5, 1, 1, 1,],
[ 1, 1, 1, 1, 1, 1,.5, 1, 1, 1, 2, 1, 1, 2,.5, 1, 1,.5,],
[ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,.5, 0,],
[ 1,.5,.5, 1,.5, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1,.5, 2,],
[ 1,.5, 1, 1, 1, 1, 2,.5, 1, 1, 1, 1, 1, 1, 2, 2,.5, 1,],
];
  
const STAT_TOTAL_GOAL = 650;
const BASE_ABILITY_VALUE = 660/650;
const FOUR_POINT_FIVE_ABILITY_VALUE = 700/650;
const PROB_TERA_OGERPON = 1/2; // my guess for % of Ogerpon's turns where she is terastallized
const PROB_TERA_TERAPAGOS = 1/3; // my guess for % of Terapagos-Terastal's turns where they're terastallized
const SPECIES_VALUES = {
  // Only 4 valid tera types. Gets a stat-raising ability on Tera.
  'Ogerpon': 1 + PROB_TERA_OGERPON*(60/655 - (BASE_ABILITY_VALUE-1)),
  'Ogerpon-Teal-Tera': 1 + PROB_TERA_OGERPON*(60/655 - (BASE_ABILITY_VALUE-1)),
  'Ogerpon-Cornerstone': 1 + PROB_TERA_OGERPON*(48/655 - (BASE_ABILITY_VALUE-1)),
  'Ogerpon-Cornerstone-Tera': 1 + PROB_TERA_OGERPON*(48/655 - (BASE_ABILITY_VALUE-1)),
  'Ogerpon-Hearthflame': 1 + PROB_TERA_OGERPON*(60/655 - (BASE_ABILITY_VALUE-1)),
  'Ogerpon-Hearthflame-Tera': 1 + PROB_TERA_OGERPON*(60/655 - (BASE_ABILITY_VALUE-1)),
  'Ogerpon-Wellspring': 1 + PROB_TERA_OGERPON*(53/655 - (BASE_ABILITY_VALUE-1)),
  'Ogerpon-Wellspring-Tera': 1 + PROB_TERA_OGERPON*(53/655 - (BASE_ABILITY_VALUE-1)),
  // gets a stat-raising transformation & new ability on Tera
  'Terapagos-Terastal': 1 + PROB_TERA_TERAPAGOS*(725-644)/644,
  // no special treatment (aside from abilities; see below)
  // 'Terapagos': 1,
  // 'Terapagos-Stellar': 1,
}
const SPECIES_WITH_DESC = {
  // pikachuworld
  'Pikachu-World': "Can use neither Pikanium Z nor Pikashunium Z, despite being in a cap.",
  // ogerpon
  'Ogerpon': 'Can only tera into Grass/Fire/Water/Rock.\nAfter tera, ability becomes Embody Aspect (+1 Speed).',
  'Ogerpon-Teal-Tera': 'Can only tera into Grass/Fire/Water/Rock.\nAfter tera, ability becomes Embody Aspect (+1 Speed).',
  'Ogerpon-Cornerstone': 'Can only tera into Grass/Fire/Water/Rock.\nAfter tera, ability becomes Embody Aspect (+1 Defense).',
  'Ogerpon-Cornerstone-Tera': 'Can only tera into Grass/Fire/Water/Rock.\nAfter tera, ability becomes Embody Aspect (+1 Defense).',
  'Ogerpon-Hearthflame': 'Can only tera into Grass/Fire/Water/Rock.\nAfter tera, ability becomes Embody Aspect (+1 Attack).',
  'Ogerpon-Hearthflame-Tera': 'Can only tera into Grass/Fire/Water/Rock.\nAfter tera, ability becomes Embody Aspect (+1 Attack).',
  'Ogerpon-Wellspring': 'Can only tera into Grass/Fire/Water/Rock.\nAfter tera, ability becomes Embody Aspect (+1 Sp. Def).',
  'Ogerpon-Wellspring-Tera': 'Can only tera into Grass/Fire/Water/Rock.\nAfter tera, ability becomes Embody Aspect (+1 Sp. Def).',
  // terapagos
  'Terapagos-Terastal': 'After tera, becomes Terapagos-Stellar and ability becomes Teraform Zero.',
}
const SPECIES_WITH_ABILITY_VALUES = {
  'Cramorant w/ Gulp Missile': BASE_ABILITY_VALUE,
  'Cramorant-Gulping w/ Gulp Missile': 650/(650 - 1.25 * (150/4 + 0.5*(100/3))), 
  'Cramorant-Gorging w/ Gulp Missile': 650/(650 - 1.25 * (150/4 + 0.5*(50 + 50))),
  'Palafin w/ Zero to Hero': 660/530,
  'Shedinja w/ Wonder Guard': 800/650,

  // calculated to average w/ Zygarde-Complete at ~660 stat total
  'Zygarde w/ Power Construct': 660/611,
  'Zygarde-10% w/ Power Construct': 660/566,

  // calculated to equal its balanced, otherwise-identical forme
  'Wishiwashi-School w/ Schooling': (650 - 150/4)/650,
  'Wishiwashi w/ Schooling': 660/310,
  'Minior-Meteor w/ Shields Down': BASE_ABILITY_VALUE,
  'Minior w/ Shields Down': 660/711,
  
  // idk its value
  "Greninja-Ash w/ Battle Bond": BASE_ABILITY_VALUE,
  "Tatsugiri w/ Commander": BASE_ABILITY_VALUE,
  "Mimikyu w/ Disguise": BASE_ABILITY_VALUE,
  "Mimikyu-Totem w/ Disguise": BASE_ABILITY_VALUE,
  "Castform w/ Forecast": BASE_ABILITY_VALUE,
  "Morpeko w/ Hunger Switch": BASE_ABILITY_VALUE,
  "Morpeko-Hangry w/ Hunger Switch": BASE_ABILITY_VALUE,
  "Eiscue w/ Ice Face": BASE_ABILITY_VALUE,
  "Arceus w/ Multitype": BASE_ABILITY_VALUE,
  "Pecharunt w/ Poison Puppeteer": BASE_ABILITY_VALUE,
  "Silvally w/ RKS System": BASE_ABILITY_VALUE,
  "Aegislash w/ Stance Change": BASE_ABILITY_VALUE,
  "Aegislash-Blade w/ Stance Change": BASE_ABILITY_VALUE,
  'Terapagos-Terastal w/ Tera Shell': SPECIES_VALUES['Terapagos-Terastal'] * BASE_ABILITY_VALUE,
  'Terapagos-Stellar w/ Teraform Zero': BASE_ABILITY_VALUE,
  "Darmanitan w/ Zen Mode": BASE_ABILITY_VALUE,
  "Darmanitan-Zen w/ Zen Mode": BASE_ABILITY_VALUE,
  "Darmanitan-Galar w/ Zen Mode": BASE_ABILITY_VALUE,
  "Darmanitan-Galar-Zen w/ Zen Mode": BASE_ABILITY_VALUE,
  "Palafin w/ Zero to Hero": BASE_ABILITY_VALUE,
}
// effectively a Terapagos-Terastal w/ Tera Shell
SPECIES_WITH_ABILITY_VALUES['Terapagos w/ Tera Shift'] = 625/510 * SPECIES_WITH_ABILITY_VALUES['Terapagos-Terastal w/ Tera Shell'];
SPECIES_WITH_ABILITY_VALUES['Terapagos-Stellar w/ Tera Shift'] = 625/708 * SPECIES_WITH_ABILITY_VALUES['Terapagos-Terastal w/ Tera Shell'];

const ABILITY_VALUES = {
  'Beads of Ruin': 650/625, // SpD drop
  'Sword of Ruin': 650/625, // Def drop
  'Tablets of Ruin': 650/610, // Atk drop
  'Vessel of Ruin': 650/610, // SpA drop
  
  'Desolate Land': 690/650, // sunny + no water while in battle
  'Primordial Sea': 690/650, // rain + no fire while in battle
  'Drizzle': 690/650,
  'Drought': 690/650,
  'Sand Stream': 690/650,
  'Snow Warning': 690/650,
  'Orichalcum Pulse': (680 + 33)/650,
  'Hadron Engine': (650 + 30 + 33)/650,
  
  'Intrepid Sword': 690/650,
  'Dauntless Shield': 680/650,

  'Huge Power': 750/650,
  'Pure Power': 750/650,

  // Arena Trap & Shadow Tag seem less OP in Doubles
  'Arena Trap': FOUR_POINT_FIVE_ABILITY_VALUE,
  'Shadow Tag': FOUR_POINT_FIVE_ABILITY_VALUE,

  // 'Contrary': FOUR_POINT_FIVE_ABILITY_VALUE, // easier to take advantage of in Constructed
  'Fluffy': 690/650,  // x.5 damage from contact moves; *2 from fire
  'Fur Coat': 730/650,  // double DEF
  'Good as Gold': FOUR_POINT_FIVE_ABILITY_VALUE, 
  'Gorilla Tactics': 700/650, // x1.5 Atk; choiced
  'Ice Scales': 730/650, // x.5 damage from special moves
  // Illusion is worse due to differing levels
  'Imposter': 1.3,
  'Intimidate': 650/600,
  'Moody': 690/650,
  'Parental Bond': 680/650,
  // Regenator seems less OP in Doubles
  'Speed Boost': 700/650,
  // Stakeout seems less OP in Doubles
  'Supreme Overlord': (650 + .1 * (133 + 69))/650,
  'Water Bubble': 750/650, // x2 water power; can't be burned; fire resistance

  // seems better in this context (few entry hazards)
  'Multiscale': 685/650,
  'Shadow Shield': 685/650,
  
  'Wonder Guard': 650/36, // Pokestar Spirit is Lv1; Shedinja's transformers are impossibly expensive

  '': 1,
  'No Ability': 1,

  'Defeatist': 610/650,
  'Klutz': 645/650,
  'Slow Start': 550/650,
  'Stall': (650-79)/650,
  'Truant': 550/650,

  // species-dependant
  "Battle Bond": 1,
  "Commander": 1,
  "Disguise": 1,
  "Flower Gift": 1,
  "Forecast": 1,
  "Gulp Missile": 1,
  "Hunger Switch": 1,
  "Ice Face": 1,
  "Multitype": 1,
  "Poison Puppeteer": 1,
  "Power Construct": 1,
  "RKS System": 1,
  "Schooling": 1,
  "Shields Down": 1,
  "Stance Change": 1,
  "Tera Shell": 1,
  "Tera Shift": 1,
  "Teraform Zero": 1,
  "Zen Mode": 1,
  "Zero to Hero": 1,
};
const IRREPLACEABLE_ABILITIES = ['Defeatist', 'Slow Start', 'Stall', 'Truant'];

const RUN_AWAY_REFRESH_COST = 2;
const IMPROVED_ABILITIES = {
  'Illuminate': "Before battle, your opponent must reveal the Pokemon in their slot corresponding to this one."
                  + "\n(In battle: accuracy can't be lowered by others; ignores their evasiveness stat.)",
  'Honey Gather': 'Get one extra choice of species whenever you get a new Pokemon.',
  'Run Away': 'Refreshing the shop only costs $' + RUN_AWAY_REFRESH_COST + '.',
  'Ball Fetch': 'When you refresh the shop, you get an extra Poke Ball choice.'
};
const ABILITIES_WITH_UNEXPECTED_DESC = ['Wonder Guard', 'Illusion'];
const CHANGED_ABILITY_DESC = {
  'Wonder Guard': 'This Pokemon can only be damaged by supereffective moves and indirect damage.\nIt cannot get Species Changers.',
  'Illusion': 'This Pokemon appears as the last Pokemon in the party until it takes direct damage.\nLevel is NOT disguised.',
  'Multitype': 'If this Pokemon is an Arceus, its type changes to match its held Plate or Z-Crystal.',
  'Parental Bond': "This Pokemon's damaging moves hit twice. The second hit has its damage quartered. Does not affect moves with multiple targets, two-turn moves, and some others.",
  'Tera Shell': 'Terapagos-Terastal: If full HP, attacks taken have 0.5x effectiveness unless naturally immune.',
  'Teraform Zero': 'Terapagos-Stellar: Terastallizing ends the effects of weather and terrain. Once per battle.',
};
const DO_NOTHING_ABILITIES = [
  'Embody Aspect (Cornerstone)',
  'Embody Aspect (Hearthflame)',
  'Embody Aspect (Teal)',
  'Embody Aspect (Wellspring)',
]
for (const ability of DO_NOTHING_ABILITIES) {
  ABILITY_VALUES[ability] = 1;
  CHANGED_ABILITY_DESC[ability] = 'Does nothing.';
}

const CAMOMONS_DOUBLES_COMMAND = '/challenge gen9doublescustomgame @@@ Camomons Mod';

const KEY_ITEMS = {
  CHEAP_REFRESH: 'Running Shoes',
  MORE_SHOP_SLOT: 'Dowsing Machine',
  LESS_SHOP_SLOT: 'Losing Machine',
  RE_BUY: 'Shopping Cart',
  MORE_POKE_CHOICE: 'Combee Hive',
  LESS_POKE_CHOICE: 'Trubbish Bin',
  HIGHER_LEVEL: 'Black Flute',
  LOWER_LEVEL: 'White Flute',
  // adds an extra slot. KEYS CAN'T BE CHANGED w/o changing code
  TM_SLOT: 'TM Charm',
  ABILITIZER_SLOT: 'Abilitizer Charm',
  TRANSFORMER_SLOT: 'Double Helix Charm',
  EGG_SLOT: 'Oval Charm',
  HELD_ITEM_SLOT: 'Handheld Charm',
  NEXT_BATTLE_SLOT: 'Battle Charm',
  POKEBALL_SLOT: 'Pokeball Charm',
  TERA_SLOT: 'Tera Charm',
  FREE_GUARANTEED_TYPE_SLOT: 'Unlimited Encounter Power',
  MAX_NUTRIENCE_SLOT: 'EVs Charm',
  BERRY_SLOT: 'Berry Charm',
  CANDY_PARTY_SLOT: 'Candy Party Charm',
  SCOUTING_SLOT: 'Reveal Glass',
  MINT_SLOT: 'Mint Charm',
  // sets all slots. KEYS CAN'T BE CHANGED w/o changing code
  // DON'T FORGET to add it to ALL_SLOTS_KEY_ITEMS
  TM_ALL: 'Oops! All TMs',
  ABILITIZER_ALL: 'Oops! All Abilitizers',
  TRANSFORMER_ALL: 'Oops! All Species Changers',
  EGG_ALL: 'Oops! All Eggs',
  HELD_ITEM_ALL: 'Oops! All Held Items',
  NEXT_BATTLE_ALL: 'Oops! All Next Battle Only',
  POKEBALL_ALL: 'Oops! All Pokeballs',
  TERA_ALL: 'Oops! All Tera Shards',
  MAX_NUTRIENCE_ALL: 'Oops! All Max Nutrience',
  BERRY_ALL: 'Oops! All Berries',
  CANDY_PARTY_ALL: 'Oops! All Candy Parties',
  MINT_ALL: 'Oops! All Mints',
  // lv up all ___-type pokemon
  NORMAL_LV_UP: 'Exp Power: Normal',
  FIRE_LV_UP: 'Exp Power: Fire',
  WATER_LV_UP: 'Exp Power: Water',
  GRASS_LV_UP: 'Exp Power: Grass',
  ELECTRIC_LV_UP: 'Exp Power: Electric',
  ICE_LV_UP: 'Exp Power: Ice',
  FIGHTING_LV_UP: 'Exp Power: Fighting',
  POISON_LV_UP: 'Exp Power: Poison',
  GROUND_LV_UP: 'Exp Power: Ground',
  FLYING_LV_UP: 'Exp Power: Flying',
  PSYCHIC_LV_UP: 'Exp Power: Psychic',
  BUG_LV_UP: 'Exp Power: Bug',
  ROCK_LV_UP: 'Exp Power: Rock',
  GHOST_LV_UP: 'Exp Power: Ghost',
  DARK_LV_UP: 'Exp Power: Dark',
  DRAGON_LV_UP: 'Exp Power: Dragon',
  STEEL_LV_UP: 'Exp Power: Steel',
  FAIRY_LV_UP: 'Exp Power: Fairy',
  // misc., continued
  MAGIKARP: 'Fish Bowl',
  ROUNDLY_MAGIKARP: 'Auto Rod',
  LOAN: 'Loan',
  INVESTMENT: 'Investment',
  NO_TM: 'TM Ban',
  NO_ABILITIZER: 'Abilitizer Ban',
  NO_TRANSFORMER: 'Species Changer Ban',
  NO_EGG: 'Egg Ban',
  NO_HELD_ITEM: 'Held Item Ban',
  LV_UP_HIGHEST: 'Exp Crown',
  LV_UP_LOWEST: 'Exp Boots',
  LV_UP_RANDOM: 'Exp Dice',
};
// magnets. KEYS CAN'T BE CHANGED w/o changing code
for (const type of TYPES)
  KEY_ITEMS[type.toUpperCase() + '_MAGNET'] = type + ' Magnet';
  
const ALL_SLOTS_KEY_ITEMS = [
  KEY_ITEMS.TM_ALL,
  KEY_ITEMS.ABILITIZER_ALL,
  KEY_ITEMS.TRANSFORMER_ALL,
  KEY_ITEMS.EGG_ALL,
  KEY_ITEMS.HELD_ITEM_ALL,
  KEY_ITEMS.NEXT_BATTLE_ALL,
  KEY_ITEMS.POKEBALL_ALL,
  KEY_ITEMS.TERA_ALL,
  KEY_ITEMS.MAX_NUTRIENCE_ALL,
  KEY_ITEMS.BERRY_ALL,
  KEY_ITEMS.CANDY_PARTY_ALL,
  KEY_ITEMS.MINT_ALL,
];

const TYPE_STONES = {
  'Fire Stone': 'Fire',
  'Ice Stone': 'Ice',
  'Leaf Stone': 'Grass',
  'Thunder Stone': 'Electric',
  'Water Stone': 'Water',
}

const UP_GRADE_MIN_DIFF = 1;
const UP_GRADE_MAX_DIFF = 50;
const IMPROVED_ITEMS = {
  'Oval Stone': 'Each round, automatically levels up.',
  'Dubious Disc': 'This Pokemon can no longer be edited or replaced.',
  'Up-Grade': 'Each round, automatically tries to transform into a random species with a ' 
                  + UP_GRADE_MIN_DIFF + '-' + UP_GRADE_MAX_DIFF + ' higher effective stat total.',
  'Sun Stone': 'Each round, automatically gets a random high-priority move in a NEW move slot.',
  'Moon Stone': 'Each round, automatically gets a random low-priority move in a NEW move slot.',
  'Dawn Stone': 'Each round, automatically sets EVERY move slot to a random move.',
  'Dusk Stone': 'Each round, automatically levels up, but forgets a random move (a Pokemon with no moves learns Struggle).',
  'Big Nugget': 'Each round, earn $30.',
};
for (let i = 0; i < POWER_ITEMS.length; i++)
  IMPROVED_ITEMS[POWER_ITEMS[i]] = "Holder's Speed is halved.\nEach round, it automatically gains "
          + POWER_ITEM_DELTA + ' ' + STATS[i] + ' EVs, up to the maximum of 252 (max 508 total EVs).';
for (const [key, value] of Object.entries(TYPE_STONES))
  IMPROVED_ITEMS[key] = "Each round, automatically gets a random " + value + '-type move in a NEW move slot.';

const IMPROVED_MOVES = {
  'Celebrate': 'Win the battle after this Pokemon successfully uses this move 4 times!' 
                  + '\n(Tell your opponent about this rule after your first time using it).',
  'Hold Hands': 'Win the battle after this Pokemon successfully uses this move on 3 unique allies!' 
                  + '\n(Tell your opponent about this rule after your first time using it).',
}
const MONEY_MOVES = ['Happy Hour', 'Pay Day', 'Make It Rain', 'G-Max Gold Rush'];
const MONEY_MOVE_INCOME = 15;

const AVG_HELD_ITEM_VALUE = 10 * .5; // take into account prob. each Pokemon has a held item

const NUM_SHOP_OPTIONS = 3;
const INCOME = 120;
const WIN_INCOME_DELTA = -20;
const BASE_REFRESH_COST = 3;

const ILLEGAL_FORMES = ['Gmax', 'Rapid-Strike-Gmax', 'Low-Key-Gmax'];
// These are functionally identical to another forme because of its ability, but the stats displayed are less helpful.
// Also, while it's alone, the Abilitizer price is dumb (-325 for Wishiwashi).
const ILLEGAL_DUE_TO_ABILITY = ['wishiwashi', 'terapagos'];
const STRICTLY_WORSE_MONS = [
  // misleadingly, a cap Pikachu that can't use Pikashunium Z. can't use Pikanium Z or cosplay moves, either.
  'pikachuworld',
];
const ILLEGAL_MONS = [
  // misleadingly, having Embody Aspect before Tera doesn't do anything (and it gets it for free, after Tera)
  "ogerpontealtera",
  "ogerponwellspringtera",
  "ogerponhearthflametera",
  "ogerponcornerstonetera",
];
const IDENTICAL_MONS = [
  ['sinistea', 'sinisteaantique'],
  ['polteageist', 'polteageistantique'],
  ['pikachuoriginal', 'pikachuhoenn', 'pikachusinnoh', 'pikachuunova', 'pikachukalos', 'pikachualola', 'pikachupartner'],
  ['magearna', 'magearnaoriginal'],
  ['pichu', 'pichuspikyeared'], 
  ['xerneas', 'xerneasneutral'],
  ['zarude', 'zarudedada'],
  ['keldeo', 'keldeoresolute'],
  ['cherrim', 'cherrimsunshine'],
  // required SPECIES_WITH_ABILITY_VALUES to have identical level
  ['minior', 'miniormeteor'],
  // identical except for hidden ability
  ['squawkabilly', 'squawkabillyblue', 'squawkabillyyellow', 'squawkabillywhite'],
  // identical but for 1 move
  ['pikachucosplay', 'pikachurockstar', 'pikachubelle', 'pikachupopstar', 'pikachuphd', 'pikachulibre'],
  // identical but for 1 ability (or for White-Stripe, 1 move)
  ['basculin', 'basculinbluestriped', 'basculinwhitestriped'],
  // identical but for Hold Hands/presence of hidden ability
  [...Array(18).fill('vivillon'), 'vivillonfancy', 'vivillonpokeball'],
  // identical except for Techno Blast's type (and whether it holds an item)
  ['genesect', 'genesectdouse', 'genesectshock', 'genesectburn', 'genesectchill'],
  // easily made identical due to changing its held item or ability
  ['arceus', 'arceusbug', 'arceusdark', 'arceusdragon', 'arceuselectric', 'arceusfairy', 'arceusfighting', 'arceusfire', 'arceusflying', 'arceusghost', 'arceusgrass', 'arceusground', 'arceusice', 'arceuspoison', 'arceuspsychic', 'arceusrock', 'arceussteel', 'arceuswater'],
  ['silvally', 'silvallybug', 'silvallydark', 'silvallydragon', 'silvallyelectric', 'silvallyfairy', 'silvallyfighting', 'silvallyfire', 'silvallyflying', 'silvallyghost', 'silvallygrass', 'silvallyground', 'silvallyice', 'silvallypoison', 'silvallypsychic', 'silvallyrock', 'silvallysteel', 'silvallywater'],
  // identical except for weight
  ['maushold', 'mausholdfour'],
  ['dudunsparce', 'dudunsparcethreesegment'],
  // identical but for 1 move & 1 ability
  ['toxtricity', 'toxtricitylowkey'],
  // identical but for the starting type of 1 move
  ['morpeko', 'morpekohangry'],
  // identical except for TMs offered and if its ability is changed
  ['castform', 'castformsunny', 'castformrainy', 'castformsnowy'],
  // identical except for weight and ability possibilities
  ['raticatealola', 'raticatealolatotem'],
  ['marowakalola', 'marowakalolatotem'],
  ['gumshoos', 'gumshoostotem'],
  ['vikavolt', 'vikavolttotem'],
  ['ribombee', 'ribombeetotem'],
  ['araquanid', 'araquanidtotem'],
  ['lurantis', 'lurantistotem'],
  ['salazzle', 'salazzletotem'],
  ['togedemaru', 'togedemarutotem'],
  ['mimikyu', 'mimikyutotem'],
  ['mimikyubusted', 'mimikyubustedtotem'],
  ['kommoo', 'kommoototem'],
  // different type OR stats is sufficient for exclusion, even for interchangable formes, 
  // provided forme change is not instantaneous
];
// these items do not transform the base species when given in Showdown
const FAKE_REQUIRED_ITEMS = ['Adamant Crystal', 'Lustrous Globe', 'Griseous Core', 'Vile Vial'];

const POKEBALL_PROMPTS = {
  'Repeat Ball': 'Choose a species you already own.',
  'Snag Ball': "Choose a species your opponent owns "
                  + "(not verified, so make sure your opponent indeed had this species last round).",
  'Master Ball': 'Choose a species.',
};
for (const type of TYPES)
  POKEBALL_PROMPTS[type + '-Type Ball'] = 'Choose a ' + type + '-type species.';

// for testing/studying purposes
let isCalculatingStats = false;
let levelStats;
let statStats;
function printStats() {
  isCalculatingStats = true;
  levelStats = '';
  statStats = [[], [], [], [], [], []];
  for (const species of Object.values(allSpecies)) {
    randomOfSpecies(species.name);
  }
  console.log(levelStats);
  console.log(statStats);
  isCalculatingStats = false;
}
function printMintParties() {
  let mintTsv = '';
  for (const nature of Object.keys(NATURES)) {
    const raisedStat = STATS[NATURES[nature][0]];
    const loweredStat = STATS[NATURES[nature][1]];
    if (raisedStat === loweredStat)
      continue; // skip neutral natures
    let price = 5;
    if (loweredStat === 'Atk' || loweredStat === 'SpA' || raisedStat === 'Spe')
      price = '5n+5';
    mintTsv += nature + ' Mint Party\tpartyMisc\t' + price 
      + "\t\t\t\t\t\t\t\t\t\t\tSet every Pokemon's Nature to " + nature + ' (+' + raisedStat + ', -' + loweredStat + ').\n';
  }
  console.log(mintTsv);
}
function printTwinTeraShards() {
  let tsv = '';
  for (const type of TERA_TYPES)
    tsv += 'Twin ' + type + ' Tera\tbeforeBattle\t\t\t\t\t\t\t\t\t\t\t\t'
        + "Before battle: Both players MAY set their [nth] Pokemon's Tera Type to " + type + '.\n';
    // tsv += type.toUpperCase() + "_LV_UP: 'Exp Power: " + type + "',\n";
  console.log(tsv);
}
function printPlatesAndMemories() {
  let tsv = '';
  let speciesIds = Object.keys(allSpecies).filter(speciesId => speciesId.startsWith('arceus'));
  for (const type of TYPES) {
    if (type === 'Normal')
      continue;
    const itemName = allSpecies['arceus' + type.toLowerCase()].requiredItems?.[0];
    tsv += itemName + '\theldItem\t\t\t' + speciesIds.join(',') + '\n';
  }
  speciesIds = Object.keys(allSpecies).filter(speciesId => speciesId.startsWith('silvally'));
  for (const type of TYPES) {
    if (type === 'Normal')
      continue;
    const itemName = allSpecies['silvally' + type.toLowerCase()].requiredItem;
    tsv += itemName + '\theldItem\t\t\t' + speciesIds.join(',') + '\n';
  }
  console.log(tsv);
}
function printZCrystals() {
  let tsv = '';
  for (const heldItem of Object.values(heldItems)) {
    if (heldItem.desc.startsWith('If holder has a'))
      tsv += heldItem.name + '\theldItem\n';
  }
  for (const heldItem of Object.values(heldItems)) {
    if (!heldItem.desc.startsWith('If holder has a') && heldItem.name.endsWith(' Z')) {
      let preZMove;
      const itCanUseIndex = heldItem.desc.indexOf(', it can use ');
      if (itCanUseIndex !== -1) {
        const withIndex = heldItem.desc.indexOf('with ');
        preZMove = heldItem.desc.substring(withIndex + 'with '.length, itCanUseIndex);
      } else if (heldItem.name === 'Lunalium Z')
        preZMove = 'Moongeist Beam'
      else if (heldItem.name === 'Solganium Z')
        preZMove = 'Sunsteel Strike'
      else if (heldItem.name === 'Ultranecrozium Z')
        preZMove = 'Photon Geyser'
      tsv += preZMove + ' TM & ' + heldItem.name + '\tTMAndZCrystal\n';
    }
  }
  console.log(tsv);
}
function printRequiredItems() {
  let tsv = '';
  for (const [speciesId, species] of Object.entries(allSpecies)) {
    const requiredItem = species.requiredItem;
    if (!requiredItem || species.name.startsWith('Silvally') || species.name.startsWith('Genesect')
          || species.name === 'Necrozma-Ultra'
          || FAKE_REQUIRED_ITEMS.includes(requiredItem))
      continue;

    const prevSpecies = allSpecies[getSpeciesId(species.baseSpecies)];
    const prevAbilities = Object.values(prevSpecies.abilities);
    const levels = prevAbilities.map(ability => getLevelWithAbility(prevSpecies, ability));
    const statDiffs = levels.map(level => {
      const newStatTotal = getStatTotal(species, level);
      const usualStatTotal = getStatTotal(species, getLevelWithAbility(species, species.abilities[0]));
      return newStatTotal - usualStatTotal;
    })
    const price = roundToNearest5((Math.max(...statDiffs) - AVG_HELD_ITEM_VALUE), true);

    tsv += requiredItem + '\theldItem\t' + price + '\t\t' + getSpeciesId(species.baseSpecies);
    tsv += '\t' + heldItemDesc(requiredItem) + '\n';
  }
  console.log(tsv);
}

function printInvalidItems() {
  const pokeballNames = getAllPokeballNames();
  for (const item of items) {
    if ((item.type === 'heldItem' && !getHeldItemId(item.name))
          || (item.type === 'pokeball' && !(item.name === 'Random Ball' || pokeballNames.includes(item.name)))
          || (item.requiredSpecies && item.requiredSpecies.some(speciesId => !allSpecies[speciesId]))
          || (item.requiredAbilities && item.requiredAbilities.some(ability => !getAbilityId(ability)))
          || ((item.type.includes('before')) != isBeforeBattleItem(item))
          || ((item.type === 'keyItem') && !Object.values(KEY_ITEMS).includes(item.name))
          || (item.requiredMoves && item.requiredMoves.some(move => !getMoveId(move))))
      console.error(item);
  }
  // make sure all tera shards exist, and cost $0 or more, for the sake of Tera Charm
  for (const type of TERA_TYPES) {
    let item = items.find(item => item.name === type + ' Tera Shards');
    if (item == null) {
      console.error('"' + type + ' Tera Shards" not found');
      break;
    } else if (item.price < 0) {
      console.error(item);
    }
  }
}
function getAllPokeballNames() {
  const pokeballEle = document.getElementById('pokeball');
  return Array.from(pokeballEle.options).map(option => option.value);
}

function printTRs() {
  let tsv = '';
  for (const tr of getTRs())
    tsv += tr.name + '\theldItem\t25\t0.1\t\t\t\t\t\t\tadds the move ' + tr.moveName + '\n';
  console.log(tsv);
}
function getTRs() {
  return Object.values(heldItems).filter(heldItem => isTR(heldItem))
    .map(heldItem => ({
      name: heldItem.name,
      moveName: getTRMoveName(heldItem),
    }));
}
function isTR(heldItem) {
  if (heldItem == null)
    return false;
  return /^TR[0-9]{2}$/.test(heldItem.name);
}
function getTRMoveName(heldItem) {
  return heldItem.desc.slice('Teaches certain Pokemon the move '.length, -1 * '. One use.'.length);
}

function printTypeMatchupGrid(arr) {
  // starting point: https://github.com/filipekiss/pokemon-type-chart/blob/master/types.json
  const grid = [];
  for (let matchup of arr) {
    const attackIndex = TYPES.indexOf(matchup.name);
    grid[attackIndex] = Array(TYPES.length).fill('1');
    for (let defenseType of matchup.immunes)
      grid[attackIndex][TYPES.indexOf(defenseType)] = '0';
    for (let defenseType of matchup.weaknesses)
      grid[attackIndex][TYPES.indexOf(defenseType)] = '.5';
    for (let defenseType of matchup.strengths)
      grid[attackIndex][TYPES.indexOf(defenseType)] = '2';
  }
  
  let out = '[\n';
  for (const row of grid) {
    out += '[';
    for (const cell of row)
      out += (cell + ',').padStart(3);
    out += '],\n';
  }
  out += ']';
  console.log(out);
}

function print1TimeTwinItems() {
  let tsv = '';
  for (const item of items.filter(item => item.type === 'nextHeldItem')) {
    let itemCopy = structuredClone(item);
    itemCopy.name = item.name.replace('Forced', '1-Time Twin') + 's';
    itemCopy.price = '';
    itemCopy.desc = item.desc.replace('Your', 'Both you and your');
    tsv += itemToTsv(itemCopy) + '\n';
  }
  for (const item of items.filter(item => item.type === 'nextAbilitizer')) {
    let itemCopy = structuredClone(item);
    itemCopy.name = item.name.replace('Forced', '1-Time Twin') + 's';
    itemCopy.price = '';
    itemCopy.desc = item.desc.replace('your', 'both you and your');
    tsv += itemToTsv(itemCopy) + '\n';
  }
  console.log(tsv);
}

function getTotalItemWeight(predicate) {
  if (predicate == null)
    predicate = item => true;
  return Object.values(items).filter(item => !hasRequirement(item) && predicate(item)).map(item => item.weight ?? 1).reduce((a,b) => a+b);
}

let numLoading = 6;
let allSpecies;
let allSpeciesIds = {};
loadAllSpecies();
let learnsets;
loadLearnsets();
let moves;
loadMoves();
let abilities;
loadAbilities();
let heldItems;
loadHeldItems();
let items = [];
loadItems();

// global variables
let roundCounter = 0;
const prevSeenSpecies = new Set();
const prevSeenItems = new Set();
let bossLevelUps = null;
let startingNumSlots = null;

onLoad();

function onLoad() {
  setPartySize(4);
  
  function generateSpeciesOnEnter(event) {
    if (event.key === 'Enter') {
      event.preventDefault();
      generateSpecificSpecies();
    }
  }
  document.getElementById('speciesInput').addEventListener('keyup', generateSpeciesOnEnter);
  document.getElementById('abilityInput').addEventListener('keyup', generateSpeciesOnEnter);
  
  const pokeballEle = document.getElementById('pokeball');
  pokeballEle.addEventListener('change', event => {
    updatePokeballDesc(pokeballEle.value);
  });

  document.getElementById('camomons').addEventListener('change', event => {
   document.getElementById('camomonsCommand').hidden = !isCamomons();
  });
  
  document.getElementById('money').addEventListener('change', event => {updateTax()});

  document.getElementById('keyItems').addEventListener('focusout', function() {
    updateKeyItemsEle();
  }, false);
  
  setNumRounds(4);
  document.getElementById('endless').checked = false;
  document.getElementById('camomons').checked = false;
  document.getElementById('camomonsCommand').hidden = true;
  document.getElementById('bossBattle').checked = false;
  document.getElementById('vsBossBattle').checked = false;

  resetRoundBasedInputs();

  document.getElementById('nextRound').textContent += ' ($' + INCOME + ')';
  document.getElementById('skip').hidden = true;
  setMoney(0);
  updateRefreshCost();
  const extraIncomeLabel = document.getElementById('extraIncomeLabel');
  extraIncomeLabel.title = 'Check this box if you '
    + 'successfully used any of the following moves last round: \n'
    + MONEY_MOVES.join(', ') + '.';
  extraIncomeLabel.textContent += ' ($' + MONEY_MOVE_INCOME + ')';
  document.getElementById('wonLabel').textContent += ' (-$' + -WIN_INCOME_DELTA + ')';
  
  resetRoundBasedInputs();
  toggleAfterFirstRoundChoices(false);
}


function loadAllSpecies() {
  loadFile('pokedex.json', function() {
    allSpecies = JSON.parse(this.responseText);
    for ([speciesId, species] of Object.entries(allSpecies)) {
      allSpeciesIds[species.name] = speciesId;
      if (species.cosmeticFormes) {
        for (const cosmeticForme of species.cosmeticFormes)
          allSpeciesIds[cosmeticForme] = speciesId;
      }
    }
    allSpecies.missingno.types = allSpecies.missingno.types.filter(type => TYPES.includes(type));
    allSpecies.missingno.abilities = {0: 'No Ability'};
    doneLoading();
  });
}
function loadLearnsets() {
  loadFile('learnsets.json', function() {
    learnsets = JSON.parse(this.responseText);
    doneLoading();
  });
}
function loadMoves() {
  loadFile('moves.json', function() {
    moves = JSON.parse(this.responseText);
    makeNumsUnique(moves);
    doneLoading();
  });
}
function loadAbilities() {
  loadFile('abilities.json', function() {
    abilities = JSON.parse(this.responseText);
    makeNumsUnique(abilities);
    doneLoading();
  });
}
function loadHeldItems() {
  loadFile('heldItems.json', function() {
    heldItems = JSON.parse(this.responseText);
    for (const item of Object.values(heldItems)) {
      if (item.name.split(' ')[1] === 'Plate')
        item.fling = {'basePower': 90}; // oddly missing from heldItems.json
    }
    doneLoading();
  });
}
function loadItems() {
  let filename = 'items.tsv';
  // filename = 'itemsTest.tsv';
  loadFile(filename, function() {
    const responseLines = this.response.split('\n');
    for (let i = 1; i < responseLines.length; i++) {
      const splitByTab = responseLines[i].split('\t');

      const item = {
        name: splitByTab[0],
        type: splitByTab[1],
        price: splitByTab[2],
      }   

      if (splitByTab[3] !== '')
        item.weight = parseFloat(splitByTab[3]);
      if (splitByTab[4] !== '')
        item.requiredSpecies = splitByTab[4].split(',');
      if (splitByTab[5] !== '')
        item.requiredAbilities = splitByTab[5].split(',');
      if (splitByTab[6] !== '')
        item.requiredMoves = splitByTab[6].split(',');
      if (splitByTab[7] !== '')
        item.minPartySize = parseInt(splitByTab[7]);
      item.bannedIfPartyNotFull = splitByTab[8] !== '';
      item.bannedIfPartyFull = splitByTab[9] !== '';
      item.bannedFirstRound = splitByTab[10] !== '';
      item.bannedLastRound = splitByTab[11] !== '';
      item.bannedIfBoss = splitByTab[12] !== '';

      item.desc = splitByTab[13];
      
      // for testing purposes: check itemToTsv is working
      // if (!responseLines[i].startsWith(itemToTsv(item)))
      //  console.error(item);

      items.push(item);
    }
    doneLoading();
  });
}
function itemToTsv(item) {
  return item.name
      + '\t' + item.type
      + '\t' + item.price
      + '\t' + (item.weight ?? '')
      + '\t' + (item.requiredSpecies?.join(',') ?? '')
      + '\t' + (item.requiredAbilities?.join(',') ?? '')
      + '\t' + (item.requiredMoves?.join(',') ?? '')
      + '\t' + (item.minPartySize ?? '')
      + '\t' + (item.bannedIfPartyNotFull ? 'x' : '')
      + '\t' + (item.bannedIfPartyFull ? 'x' : '')
      + '\t' + (item.bannedFirstRound ? 'x' : '')
      + '\t' + (item.bannedLastRound ? 'x' : '')
      + '\t' + item.desc;
}

function copyBingoJSON() {
  const hasCrowns = document.getElementById('hasCrowns').checked;
  let filename = 'bingo.tsv';
  // filename = 'bingoTest.tsv';
  loadFile(filename, function() {
    const responseLines = this.response.replaceAll('\r','').split('\n');
    responseLines.shift();
    let linesCopy = [];
    let goals = [];
    for (let x = 0; x < 5; x++) {
      for (let y = 0; y < 5; y++) {
        if (hasCrowns && x === 4-y)
          goals.push({"name": 'üëë'});
        else {
          let splitByTab, prob;
          do {
            if (linesCopy.length === 0)
              linesCopy = [...responseLines];
            splitByTab = removeRandom(linesCopy).split('\t');
            prob = parseFloat(splitByTab[1]);
          } while (!isNaN(prob) && Math.random() > prob);
          let goal = splitByTab[0].trim() === '' ? 'üìù' : '‚öîÔ∏è'; 
          goal += ' ' + splitByTab[2];
          goals.push({"name": goal});
        }
      }
    }
    copyStr(JSON.stringify(goals) + '\n'.repeat(10));
  });
}

function loadFile(filename, onLoadFunc) {
  const xhttp = new XMLHttpRequest();
  xhttp.onload = onLoadFunc;
  xhttp.open("GET", filename);
  xhttp.send();
}

function printAlphabetTM() {
  let out = '';
  let outP = '';
  let outT = '';
  for (let i = 0; i < 26; i++) {
    const char = String.fromCharCode(65 + i);

    const movesWithStart = Object.values(moves).filter(move => 
      isLegalMove(move, false, false) && move.name.toUpperCase().startsWith(char));
    let prob = 0.5;
    let valueOfAddedChoice = 10;
    if (movesWithStart.length <= 1) {
      prob = 0.01;
      valueOfAddedChoice = 0;
    } else if (movesWithStart.length <= 5)
      valueOfAddedChoice = 5;
    
    const maxTmPrice = movesWithStart.reduce((acc, curr) => Math.max(acc, tmPrice(curr)), 0);
    const price = Math.min(maxTmPrice + 10 + valueOfAddedChoice, 50);
    const partyPrice = (maxTmPrice/2 - 3) + 'n+' + (maxTmPrice + 3 + 10 + valueOfAddedChoice);
    const twinPrice = roundToNearest5(maxTmPrice/2) + valueOfAddedChoice;

    let exceptions = 'Z-Moves or G-Max moves';
    if (char === 'S')
      exceptions = 'Z-Moves, G-Max moves, or Spore';
    else if (char === 'Z')
      exceptions = 'Z-Moves, G-Max moves, or Zippy Zap';

    out += char + '* TM\tuniversalTM\t' + price + '\t' + prob + '\t\t\t\t\t\t\t\t\t\tTeach ANY 1 Pokemon any move starting with the letter ' + char + ' (no ' + exceptions + ').\n';
    outP += char + '* Party TM\tpartyTM\t' + partyPrice + '\t' + prob + '\t\t\t\t\t\t\t\t\t\tChoose any move starting with the letter ' + char + ' (no ' + exceptions + '). Teach EVERY Pokemon that move.\n';
    outT += 'Twin ' + char + '* TMs\tbeforeTM\t' + twinPrice + '\t' + prob + "\t\t\t\t\t\t\t\t\t\tBefore battle: Both players MAY teach their [nth] Pokemon the move [_____]. Must choose a move starting with the letter " + char + " (can't choose Z-Moves).\n";
  }
  console.log(out + outP + outT);
}
function printAlphabetAbilitizers() {
  const BANNED_ABILITIES = ['Huge Power', 'Pure Power', 'Fur Coat', 'Ice Scales', 'Imposter', 'Wonder Guard'];
  let out = '';
  let outT = '';
  for (let i = 0; i < 26; i++) {
    const char = String.fromCharCode(65 + i);

    const abilitiesWithStart = Object.values(abilities).filter(ability => 
      ability.name.toUpperCase().startsWith(char) && !BANNED_ABILITIES.includes(ability.name) && isRandomableAbility(ability) && abilitizerPrice(ability) >= 0);
    if (abilitiesWithStart.length == 0)
      continue;
    let prob = 0.5;
    let valueOfAddedChoice = 10;
    if (abilitiesWithStart.length <= 1) {
      prob = 0.01;
      valueOfAddedChoice = 0;
    } else if (abilitiesWithStart.length <= 5)
      valueOfAddedChoice = 5;
    
    const maxPrice = abilitiesWithStart.reduce((acc, curr) => Math.max(acc, abilitizerPrice(curr)), 0);
    const price = Math.min(maxPrice + 20 + valueOfAddedChoice, 60);
    const twinPrice = Math.min(maxPrice + 10 + valueOfAddedChoice, 40);

    let exceptions = '.';
    const exceptionsArr = BANNED_ABILITIES.filter(ability => ability.startsWith(char));
    if (exceptionsArr.length > 0)
      exceptions = ". Can't choose " + exceptionsArr.join(' or ') + '.';

    let ending = ' <span class="warning"><br>Cannot replace Defeatist, Slow Start, Stall, or Truant.</span>\n';
    out += char + '* Abilitizer\tabilitizer\t' + price + '\t' + prob + "\t\t\t\t\t\t\t\t\t\tSet a Pokemon's ability to any ability starting with the letter " + char + exceptions + ending;
    outT += 'Twin ' + char + '* Abilitizers\tbeforeAbilitizer\t' + twinPrice + '\t' + prob + "\t\t\t\t\t\t\t\t\t\tBefore battle: Both players MAY set their [nth] Pokemon's ability to the ability [_____]. Must choose an ability starting with the letter " + char + exceptions + ending;
  }
  console.log(out + outT);
}
function printAlphabetGoals() {
  const TOO_LOW = 0.05;
  const TOO_HIGH = .2;
  const numSpecies = Object.entries(allSpecies).filter(([speciesId, species]) => isLegal(speciesId)).length;
  let out = '';
  for (let i = 0; i < 26; i++) {
    const char = String.fromCharCode(65 + i);

    let prob = Object.entries(allSpecies).filter(([speciesId, species]) => 
      isLegal(speciesId) && species.name.toUpperCase().includes(char)).length/numSpecies;
    if (TOO_LOW < prob && prob < TOO_HIGH)
      out += "Pokemon name includes " + char + "\n";

    prob = Object.entries(allSpecies).filter(([speciesId, species]) => 
      isLegal(speciesId) && species.name.toUpperCase().startsWith(char)).length/numSpecies;
    if (TOO_LOW < prob && prob < TOO_HIGH)
      out += "Pokemon name starts w/ " + char + "\n";
  }
  console.log(out);
}
function printAlphabetMoveGoals() {
  const TOO_LOW = 0.02;
  const TOO_HIGH = .1;
  const numMoves = Object.values(moves).filter(move => isLegalMove(move, true, true)).length;
  let out = '';
  for (let i = 0; i < 26; i++) {
    const char = String.fromCharCode(65 + i);

    let prob = Object.values(moves).filter(move => 
      isLegalMove(move, true, true) && move.name.toUpperCase().includes(char)).length/numMoves;
    if (TOO_LOW < prob && prob < TOO_HIGH)
      out += "move name includes " + char + "\n";

    prob = Object.values(moves).filter(move => 
      isLegalMove(move, true, true) && move.name.toUpperCase().startsWith(char)).length/numMoves;
    if (TOO_LOW < prob && prob < TOO_HIGH)
      out += "move name starts w/ " + char + "\n";
  }
  console.log(out);
}
function printAlphabetAbilityGoals() {
  const TOO_LOW = 0.05;
  const TOO_HIGH = .2;
  const numAbilities = Object.values(abilities).length;
  let out = '';
  for (let i = 0; i < 26; i++) {
    const char = String.fromCharCode(65 + i);

    let prob = Object.values(abilities).filter(ability => 
      ability.name.toUpperCase().includes(char)).length/numAbilities;
    if (TOO_LOW < prob && prob < TOO_HIGH)
      out += "ability name includes " + char + "\n";

    prob = Object.values(abilities).filter(ability => 
      ability.name.toUpperCase().startsWith(char)).length/numAbilities;
    if (TOO_LOW < prob && prob < TOO_HIGH)
      out += "ability name starts w/ " + char + "\n";
  }
  console.log(out);
}

function doneLoading() {
  numLoading--;
  if (numLoading === 0) {
    printInvalidItems();
    addTRsToImprovedItems(); // requires heldItems and moves to be loaded in
  }
}

function makeNumsUnique(objs) {
  const lastSeenObjOfNum = [];
  for (const obj of Object.values(objs)) {
    const numWithoutDecimal = obj.num;
    const lastSeenObj = lastSeenObjOfNum[obj.num];
    if (lastSeenObj) {
      if (typeof lastSeenObj.num === 'number')
        lastSeenObj.num += '.1';
      obj.num += '.' + (parseInt(lastSeenObj.num.split('.')[1]) + 1);
    }
    lastSeenObjOfNum[numWithoutDecimal] = obj;
  }
}

function addTRsToImprovedItems() {
  for (const tr of getTRs()) 
    IMPROVED_ITEMS[tr.name] = '+1 shop slot with free Universal TMs for ' + tr.moveName + '.\n\n'
            + moveDesc(moves[getMoveId(tr.moveName)], true);
}

function addPartySlot(fromUserInput) {
  const partyDiv = document.getElementById('party');

  let lastFlexRow = partyDiv.children[partyDiv.children.length-1];
  if (lastFlexRow == null || lastFlexRow.children.length >= 2) {
    if (partyDiv.children.length >= 12) {
      if (fromUserInput)
        alert("Pokemon Showdown can't handle more than 24 Pokemon in a team.");
      return false;
    }
    lastFlexRow = document.createElement('div');
    lastFlexRow.classList.add('flex-row');
    partyDiv.append(lastFlexRow);
  }

  const pokeDiv = document.createElement('div');
  fillPokemonDiv(pokeDiv, true, false);
  lastFlexRow.append(pokeDiv);

  return true;
}

function losePartySlot() {
  const partyDiv = document.getElementById('party');

  const lastFlexRow = partyDiv.children[partyDiv.children.length-1];
  if (lastFlexRow == null)
    return;

  const lastPokeDiv = lastFlexRow.children[lastFlexRow.children.length-1];
  if (getPokeEle(lastPokeDiv).innerText.trim() !== '') {
    alert('You must delete your last Pokemon before deleting its slot.');
    return;
  }
  lastPokeDiv.remove();

  if (lastFlexRow.children.length == 0)
    lastFlexRow.remove();
}

function setPartySize(partySize) {
  const partyDiv = document.getElementById('party');
  killAllChildren(partyDiv);
  for (let i = 0; i < partySize; i++)
    addPartySlot();
}
function fillPokemonDiv(div, editable, noMoveHeight) {
  div.classList.add('pokemon-div');

  const pokemonEle = document.createElement('p');
  pokemonEle.classList.add('info-box', 'pokemon');
  if (editable) {
    pokemonEle.setAttribute('contenteditable', true);
    pokemonEle.setAttribute('spellcheck', false);
    pokemonEle.classList.add('editable');
    pokemonEle.addEventListener('focusout', function() {
      if (pokemonEle.innerText.includes(' @ Dubious Disc'))
        if (confirm('WARNING: this slot will no longer be editable.'))
          removeEditable(pokemonEle);
        else
          pokemonEle.innerText = pokemonEle.innerText.replace(' @ Dubious Disc', '');
      updatePartyPokemonDiv(div);
    }, false);
  }
  if (noMoveHeight)
    pokemonEle.classList.add('no-move-height');
  div.append(pokemonEle);

  const typesEle = document.createElement('div');
  typesEle.classList.add('overlay', 'types', 'position-left');
  div.append(typesEle);

  const teraTypeEle = document.createElement('div');
  teraTypeEle.classList.add('overlay', 'tera-type');
  div.append(teraTypeEle);

  const statsEle = document.createElement('p');
  statsEle.classList.add('info-box', 'stats');
  div.append(statsEle);
}
function updatePartyPokemonDiv(div) {
  updateRefreshCost();
  updateTMSeekerOptions();
  updatePokemonDiv(div);
}

function removeEditable(pokemonEle) {
  pokemonEle.setAttribute('contenteditable', false);
  pokemonEle.classList.remove('editable');
}

function numOfKeyItem(keyItemName) {
  let num = 0;
  for (const ownedKeyItem of getKeyItems()) {
    if (keyItemName === ownedKeyItem)
      num++;
  }
  return num;
}

function updateKeyItemsEle() {
  const ele = document.getElementById('keyItems');
  let html = '';
  for (const keyItemName of getKeyItems()) {
    const keyItem = Object.values(items).find(item => item.name === keyItemName);
    if (keyItem == null)
      html += keyItemName;
    else
      html += spanWithTitle(keyItemName, keyItem.desc);
    html += '\n';
  }
  ele.innerHTML = html.slice(0, -1);

  updateRefreshCost();
}

function getKeyItems() {
  return document.getElementById('keyItems').innerText.split('\n').map(line => line.trim());
}

// https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event#examples
const beforeUnloadListener = (event) => {
  event.preventDefault();
  return (event.returnValue = "");
};

function updatePokemonDiv(div) {
  const pokemonEle = getPokeEle(div);
  const pokemonStr = pokemonEle.innerText;

  if (pokemonStr.trim() === '') {
    pokemonEle.style.backgroundImage = '';
    killAllChildren(div.querySelector('.types'));
    killAllChildren(div.querySelector('.tera-type'));
    div.querySelector('.stats').innerHTML = '';
    return;
  }

  if (getPartyPokeDivs().includes(div))
    addEventListener("beforeunload", beforeUnloadListener, { capture: true });

  pokemonEle.innerHTML = pokemonInHTML(pokemonStr);

  const speciesName = getSpeciesNameOfPokemon(pokemonStr);
  pokemonEle.style.backgroundImage = getImageURL(speciesName, pokemonStr.includes('Shiny: Yes'));

  const typesEle = div.querySelector('.types');
  killAllChildren(typesEle);
  let types = getTypesOfPokemon(pokemonStr);
  typesEle.innerHTML = getTypesHTML(types, true);

  const teraTypeEle = div.querySelector('.tera-type');
  killAllChildren(teraTypeEle);
  if (pokemonCanTera(pokemonStr)) {
    const teraType = getTeraTypeOfPokemon(pokemonStr);
    if (teraType != null)
      teraTypeEle.innerHTML = getTypesHTML([teraType], false);
  }
  
  const statsEle = div.querySelector('.stats');
  statsEle.innerHTML = statsInHTML(getStatRelevantInfo(pokemonStr), true);
}
function getTypesHTML(types, positionLeft, mlBody) {
  let typesHTML = '';
  for (const type of types)
    typesHTML += getTypeImageHTML(type, false);

  let matchupInnerHTML = '';
  if (types[0] === 'Stellar') {
    matchupInnerHTML = '<span class="attr">(Unchanged)</span>';
  } else {
    for (const [matchupNum, attackTypes] of getTypeMatchups(types)) {
      if (attackTypes.length > 0) {
        matchupInnerHTML += matchupNumToStr(matchupNum) + ': ';
        for (const attackType of attackTypes)
          matchupInnerHTML += getTypeImageHTML(attackType, true);
        matchupInnerHTML += '\n';
      }
      if (matchupNum === 2)
        matchupInnerHTML += '<hr>';
    }
  }
  typesHTML += '<div class="info-box matchups' + (positionLeft ? ' position-left' : '') + (mlBody ? ' ml-body' : '') + '">' 
            + matchupInnerHTML + '</div>';

  return typesHTML;
}

function getTypeImageHTML(type, textAligned) {
  return '<img ' + (textAligned ? 'class="text-aligned-img"' : '') 
                 + ' src="' + getTypeImageURL(type) + '">';
}
function getTypeImageURL(type) {
  return 'https://play.pokemonshowdown.com/sprites/types/' + type + '.png';
}

function getTypesOfPokemon(pokemonStr) {
  if (isCamomons()) {
    let movesSeen = 0;
    const types = [];
    const splitStr = pokemonStr.split('\n- ');
    for (let i = 1; i < splitStr.length && movesSeen < 2; i++) {
      const moveId = getMoveId(splitStr[i]);
      if (moveId == null)
        continue;
      movesSeen++;
      let type = moves[moveId].type;
      if (moves[moveId].name.startsWith('Hidden Power'))
        type = 'Normal';
      if (!types.includes(type))
        types.push(type);
    }
    return types;
  } else {
    return allSpecies[getSpeciesIdOfPokemon(pokemonStr)].types;
  }
}

function matchupNumToStr(matchupNum) {
  switch (matchupNum) {
    case   0: return '  0';
    case .25: return '1/4';
    case  .5: return '1/2';
    case   2: return '  2';
    case   4: return '  4';
    default: throw new Error('Invalid matchupNum: ' + matchupNum);
  }
}

function getNumWeakness(defendTypes) {
  let typeMatchups = getTypeMatchups(defendTypes);
  return typeMatchups[0][1].length + typeMatchups[1][1].length;
}
function getTypeMatchups(defendTypes) {
  let matchups = [[4,[]], [2,[]], [.5,[]], [.25,[]], [0,[]]];
  for (const attackType of TYPES) {
    const attackTypes = matchups.find(arr => arr[0] === getTypeMatchup(attackType, defendTypes));
    if (attackTypes)
      attackTypes[1].push(attackType);
  }
  return matchups;
}
function getTypeMatchup(attackType, defendTypes) {
  let matchup = 1;
  for (const defendType of defendTypes)
    matchup *= TYPE_MATCHUPS[TYPES.indexOf(attackType)][TYPES.indexOf(defendType)];
  return matchup;
}

function getProperSpeciesName(speciesNameInput) {
  const simplifiedInput = speciesNameInput.toLowerCase().replaceAll(/[^a-zA-Z0-9]/g, '');
  for (const species of Object.values(allSpecies)) {
    const names = [species.name];
    if (species.cosmeticFormes)
      names.push(...species.cosmeticFormes);
    for (const name of names) {
      if (name.toLowerCase().replaceAll(/[^a-zA-Z0-9]/g, '') === simplifiedInput)
        return name;
    }
  }
}

function getProperAbilityName(abilityNameInput) {
  const simplifiedInput = abilityNameInput.toLowerCase().replaceAll(/[^a-zA-Z0-9]/g, '');
  for (const ability of Object.values(abilities)) {
    if (ability.name.toLowerCase().replaceAll(/[^a-zA-Z0-9]/g, '') === simplifiedInput)
      return ability.name;
  }
}

function getSpeciesId(speciesName) {
  return allSpeciesIds[speciesName];
}
function getMoveId(moveName) {
  return Object.keys(moves).find(moveId => moves[moveId].name === moveName);
}
function getAbilityId(abilityName) {
  return Object.keys(abilities).find(abilityId => abilities[abilityId].name === abilityName);
}
function getHeldItemId(heldItemName) {
  return Object.keys(heldItems).find(heldItemId => heldItems[heldItemId].name === heldItemName);
}

function killAllChildren(div) {
  while (div.firstChild)
    div.removeChild(div.firstChild);
}

function addChoices(choicesDiv) {
  const pokeball = getPokeball();
  if (POKEBALL_PROMPTS[pokeball] !== undefined) {
    const speciesNameInput = prompt(POKEBALL_PROMPTS[pokeball]);
    if (speciesNameInput == null)
      return false;
    const speciesName = getProperSpeciesName(speciesNameInput);
    if (!speciesName) {
      alert('Error: species name not recognized.');
      return false;
    }
    const speciesId = getSpeciesId(speciesName);
    if (pokeball === 'Repeat Ball' &&
        !getPartyStrs().map(pokemonStr => getApparentSpeciesNameOfPokemon(pokemonStr)).includes(speciesName)) {
      alert('You must choose a species you already own!');
      return false;
    }
    const species = allSpecies[speciesId];
    if (!isLegal(speciesId, null, false, true)) {
      alert('Error: please pick a different forme for this Pokemon.');
      return false;
    }
    const requiredType = pokeball.split('-Type ')[0];
    if (TYPES.includes(requiredType) && !species.types.includes(requiredType)) {
      alert('You must choose a ' + requiredType + '-type!');
      return false;
    }
    for (const abilityName of Object.values(species.abilities))
      addRandomPokemon(choicesDiv, true, speciesName, abilityName);
  } else {
    let numPokeChoices = numChoices();
    numPokeChoices += numPokemonWithAbility('Honey Gather');
    numPokeChoices += numOfKeyItem(KEY_ITEMS.MORE_POKE_CHOICE);
    numPokeChoices -= numOfKeyItem(KEY_ITEMS.LESS_POKE_CHOICE);
    if (numPokeChoices < 1)
      numPokeChoices = 1;

    let abilityName = null;
    if (pokeball === 'Truant Ball')
      abilityName = 'Truant';
    if (pokeball === 'Wonder Ball')
      abilityName = 'Wonder Guard';

    let speciesPredicate;
    if (pokeball === 'Wonder Ball')
      speciesPredicate = ((species) => getNumWeakness(species.types) <= 2);
    for (let i = 0; i < numPokeChoices; i++)
      addRandomPokemon(choicesDiv, true, null, abilityName, false, false, speciesPredicate);
  }
  return true;
}
function numChoices() {
  switch (getPokeball()) {
    case 'Great Ball':
    case 'Nest Ball':
      return 3;
    case 'Ultra Ball':
      return 4;
    case 'Quick Ball':
      return 1;
    default:
      return 2;
  }
}

function generateSpecificSpecies() {
  const speciesDiv = document.getElementById('species');
  const speciesName = getProperSpeciesName(document.getElementById('speciesInput').value.trim());
  const species = getSpeciesId(speciesName);

  const speciesErrorEle = document.getElementById('speciesError');
  if (!species) {
    speciesErrorEle.textContent = 'ERROR: species name not recognized';
    return;
  }

  const speciesRow = document.createElement('div');
  speciesRow.classList.add('flex-row', 'generated-species-row');
  speciesDiv.prepend(speciesRow);

  let abilityNameInput = document.getElementById('abilityInput').value.trim();
  if (abilityNameInput === '') {
    for (const abilityName of Object.values(allSpecies[species].abilities))
      addRandomPokemon(speciesRow, false, speciesName, abilityName, 'random', isVsBoss());
  } else {
    const abilityName = getProperAbilityName(abilityNameInput);
    if (abilityName == null) {
      speciesErrorEle.textContent = 'ERROR: ability name not recognized';
      return;
    }
    addRandomPokemon(speciesRow, false, speciesName, abilityName, 'random', isVsBoss());
  }

  speciesErrorEle.textContent = '';

  // // list all formes
  // let formes = {};
  // for (const speciesId of Object.keys(allSpecies)) {
  //   if (allSpecies[speciesId].forme) {
  //     if (!formes[allSpecies[speciesId].forme])
  //       formes[allSpecies[speciesId].forme] = [];
  //     formes[allSpecies[speciesId].forme].push(speciesId);
  //   }
  // }
  // console.log(formes);
}

function isLegal(speciesId, requiredType, ignoreDueToAbility, ignoreStrictlyWorse) {
  const species = allSpecies[speciesId];
  if (species.forme && ILLEGAL_FORMES.includes(species.forme))
    return false;
  if (ILLEGAL_MONS.includes(speciesId))
    return false;
  if (!ignoreDueToAbility && ILLEGAL_DUE_TO_ABILITY.includes(speciesId))
    return false;
  if (!ignoreStrictlyWorse && STRICTLY_WORSE_MONS.includes(speciesId))
    return false;
  if (requiredType && !species.types.includes(requiredType))
    return false;
  return true;
}
function passesIdenticalSpeciesBias(speciesId) {
  const identicals = IDENTICAL_MONS.find(arr => arr.includes(speciesId));
  if (identicals)
    return speciesId === randomElement(identicals);
  else
    return true;
}

function addRandomPokemon(choicesDiv, hasChooseButton, speciesName, abilityName, teraType, showBossLevelUps, speciesPredicate) {  
  let pokeball = null;
  if (hasChooseButton)
    pokeball = getPokeball();
  
  if (speciesName == null) {
    let requiredType = getGuaranteedType();
    if (!TYPES.includes(requiredType))
      requiredType = null;
    
    const illegalSpeciesNames = [];
    if (isBoss())
      illegalSpeciesNames.push('Pokestar Spirit');
    speciesName = randomSpeciesName(requiredType, illegalSpeciesNames, false, speciesPredicate, abilityName == null&& pokeball !== 'Strange Ball');
  }
  
  let pokemonStr = randomOfSpecies(speciesName, abilityName, pokeball, null, teraType, hasChooseButton, hasChooseButton, showBossLevelUps);

  if (hasChooseButton) {
    switch (pokeball) {
      case 'Moon Ball':
        pokemonStr += '\n- Moonlight';
        break;
      case 'Dream Ball':
        pokemonStr += '\n- Rest\n- Sleep Talk';
        break;
      case 'Friend Ball':
        pokemonStr += '\n- Return';
        break;
      case 'Love Ball':
        pokemonStr += '\n- Attract';
        break;
    }
  }
  
  if (pokeball === 'Love Ball') {
    addPokemon(choicesDiv, hasChooseButton, pokemonStr.replace(GENDER_PLACEHOLDER, 'M'));
    addPokemon(choicesDiv, hasChooseButton, pokemonStr.replace(GENDER_PLACEHOLDER, 'F'));
  } else {
    addPokemon(choicesDiv, hasChooseButton, pokemonStr);
  }
}
function addPokemon(choicesDiv, hasChooseButton, pokemonStr) {
  const divEle = document.createElement('div');
  fillPokemonDiv(divEle, !hasChooseButton, true);
  
  const pokemonEle = getPokeEle(divEle);
  pokemonEle.innerHTML = pokemonStr;
  
  if (hasChooseButton) {
    const buttonEle = document.createElement('button');
    buttonEle.innerText = 'choose';
    buttonEle.onclick = function() {choosePokemon(choicesDiv, pokemonStr)};
    divEle.append(buttonEle);
  }
  
  updatePokemonDiv(divEle);
  
  choicesDiv.append(divEle);
}

function randomSpeciesName(requiredType, illegalSpeciesIds, canBePrevSeen, speciesPredicate, hasOriginalAbility) {
  if (speciesPredicate) // true iff Wonder Ball, at least for now
    requiredType = null;
  let speciesId;
  let failsafe = 1000;
  do {
    speciesId = randomKey(allSpecies);
    if (!canBePrevSeen && failsafe-- < 0)
      prevSeenSpecies.clear();
  } while (!isLegal(speciesId, requiredType, !hasOriginalAbility) 
              || !passesIdenticalSpeciesBias(speciesId)
              || (illegalSpeciesIds && illegalSpeciesIds.includes(speciesId))
              || (speciesPredicate && !speciesPredicate(allSpecies[speciesId]))
              || (!canBePrevSeen && prevSeenSpecies.has(speciesId)));
  if (!canBePrevSeen)
    prevSeenSpecies.add(speciesId);

  const species = allSpecies[speciesId];
  return randomCosmeticName(species);
}
function randomCosmeticName(species) {
  let speciesName = species.name;

  if (species.cosmeticFormes && !isPokestar(species.name)) {
    const randy = randomInt(species.cosmeticFormes.length + 1);
    if (randy < species.cosmeticFormes.length)
      speciesName = species.cosmeticFormes[randy];
  }
  return speciesName;
}

function isPokestar(speciesName) {
  return speciesName.startsWith('Pokestar');
}

function getImageURL(speciesName, isShiny) {
  return 'url(https://play.pokemonshowdown.com/sprites/gen5' + (isShiny ? '-shiny' : '') + '/' 
              + getImageUrlName(speciesName) + '.png)';
}
function getImageUrlName(speciesName) {
  if (speciesName === 'Unown-Question')
    return 'unown-qm';
  if (speciesName === 'Unown-Exclamation')
    return 'unown-em';
  if (speciesName.endsWith('-Totem'))
    speciesName = speciesName.slice(0, -1 * '-Totem'.length);
  if (speciesName.startsWith('Furfrou'))
    return 'furfrou';
  if (speciesName.startsWith('Vivillon') && !['Vivillon-Fancy', 'Vivillon-Pokeball'].includes(speciesName))
    return 'vivillon';
  const species = allSpecies[getSpeciesId(speciesName)];
  if (species.baseSpecies || species.cosmeticFormes?.includes(speciesName)) {
    let baseSpeciesName = species.baseSpecies ?? species.name;
    let formeName = speciesName.substring(baseSpeciesName.length + 1);
    speciesName = baseSpeciesName.replaceAll('-', '') + '-' + formeName.replaceAll('-', '');
  } else {
    speciesName = speciesName.replaceAll('-', '');
  }
  return speciesName.toLowerCase().replaceAll(/[^a-zA-Z0-9\-]/g, '');
}

const GENDER_PLACEHOLDER = '[GENDER]';

function randomOfSpecies(speciesName, abilityName, pokeball, level, teraType, canBeShiny, hasChooseButton, showBossLevelUps) {
  const speciesId = getSpeciesId(speciesName);
  const species = allSpecies[speciesId];

  let displayName = speciesName;
  let heldItemName;

  let gender;
  if (pokeball === 'Love Ball')
    gender = GENDER_PLACEHOLDER;
  else {
    if (species.gender)
      gender = species.gender;
    else {
      let probMale = .5;
      if (species.genderRatio)
        probMale = species.genderRatio.M;
      gender = Math.random() < probMale ? 'M' : 'F';
    }
  }

  if (species.baseSpecies === 'Arceus') {
    displayName = species.baseSpecies;
    heldItemName = species.requiredItems[0];
  }
  else if (species.baseSpecies === 'Silvally' || species.baseSpecies === 'Genesect') {
    displayName = species.baseSpecies;
    heldItemName = species.requiredItem;
  }

  let pokemonStr = displayName;
  if (gender !== 'N')
    pokemonStr += ' (' + gender + ')';
  if (heldItemName)
    pokemonStr += ' @ ' + heldItemName;

  if (abilityName == null) {
    if (pokeball === 'Strange Ball')
      abilityName = randomAbilitizerAbility().name;
    else
      abilityName = randomValue(species.abilities);
  }
  pokemonStr += '\nAbility: ';
  if (abilityName)
    pokemonStr += abilityName;

  if (level == null)
    level = getLevelWithAbility(species, abilityName);
  if (pokeball === 'Nest Ball')
    level -= 1;
  if (pokeball === 'Quick Ball')
    level += 3;
  if (hasChooseButton) {
    level += numOfKeyItem(KEY_ITEMS.HIGHER_LEVEL);
    level -= numOfKeyItem(KEY_ITEMS.LOWER_LEVEL);
    if (isBoss() && getPartyStrs().length > 0)
      level = 1;
  }
  if (abilityName === 'Wonder Guard' && species.name !== 'Shedinja')
    level = 1;
  if (level < 1)
    level = 1;

  pokemonStr += '\nLevel: ' + level;

  if (showBossLevelUps)
    pokemonStr += getBossLevelUps(species, abilityName).map(lvUp => ' +' + lvUp).join('');

  if (isCalculatingStats) {
    levelStats += level + ', ';
    for (let i = 0; i < STATS.length; i++) {
      statStats[i].push(getStat(species, level, null, null, STATS[i]));
    }
  }

  if (canBeShiny && Math.random() < 1/1024)
    pokemonStr += '\nShiny: Yes';

  pokemonStr += '\nTera Type: ';
  if (teraType || !canTera(species, heldItems[getHeldItemId(heldItemName)]) || forcedTera(species)) {
    if (TERA_TYPES.includes(teraType))
      pokemonStr += teraType;
    else { // we sometimes uses teraType='random' to reach this case
      if (isOgerpon(species))
        pokemonStr += randomElement(OGERPON_TERA_TYPES);
      else
        pokemonStr += randomElement(TERA_TYPES);
    }
  }
    
  pokemonStr += '\nEVs: 1 HP';

  return pokemonStr;
}

function updateBossLevelUps() {
  let str = 'Level raises: +' + bossLevelUps.join(', +') + '.';
  if (bossLevelUps.length === 0)
    str = '';
  document.getElementById('bossLevelUps').textContent = str;
}
function isBoss() {
  return document.getElementById('bossBattle').checked;
}
function isVsBoss() {
  return document.getElementById('vsBossBattle').checked;
}

function isCamomons() {
  return document.getElementById('camomons').checked;
}

function allMoveIdsSuchThat(predicate) {
  return Object.entries(moves).filter(([moveId, move]) => predicate(move)).map(arr => arr[0]);
}

function getLearnset(speciesId) {
  if (speciesId === 'smeargle')
    return allMoveIdsSuchThat(move => isLegalMove(move, false, false)
              && move.name !== 'Chatter' && move.name !== 'Struggle');
  const species = allSpecies[speciesId];
  let learnset;
  if (isPokestar(species.name)) {
    learnset = new Set();
    for (const eventDatum of learnsets[speciesId].eventData)
      for (const moveId of eventDatum.moves)
        learnset.add(moveId);
  } else {
    let learnsetData = learnsets[speciesId];

    if (!learnsetData?.learnset)
      learnsetData = learnsets[species.baseSpecies.toLowerCase()];

    learnset = new Set(Object.keys(learnsetData.learnset));

    let baseSpeciesId = speciesId;
    if (learnset.size < 4) {
      let changesFrom;
      if (species.changesFrom)
        changesFrom = species.changesFrom;
      else if (species.baseSpecies)
        changesFrom = species.baseSpecies;
      
      if (changesFrom) {
        baseSpeciesId = getSpeciesId(changesFrom);
        const baseSepeciesLearnset = Object.keys(learnsets[baseSpeciesId].learnset);
        for (const moveId of baseSepeciesLearnset)
          learnset.add(moveId);
      }
    }

    const preEvoName = allSpecies[baseSpeciesId].prevo;
    if (preEvoName) {
      const preEvoLearnset = getLearnset(getSpeciesId(preEvoName));
      for (const moveId of preEvoLearnset)
        learnset.add(moveId)
    }
  }
  return Array.from(learnset);
}

function getLevelWithAbility(species, abilityName, statTotalMultiplier) {
  // we want: stat goal * ability value = base stat goal * base ability value
  let statTotalGoal =  STAT_TOTAL_GOAL * BASE_ABILITY_VALUE / getAbilityValue(species, abilityName);
  if (statTotalMultiplier)
    statTotalGoal *= statTotalMultiplier;
  return getLevel(species, statTotalGoal);
}
function getAbilityValue(species, abilityName) {
  let speciesName = species?.name;
  if (speciesName != null)
    speciesName = allSpecies[getSpeciesId(speciesName)].name; // remove cosmetic forme

  if (     SPECIES_WITH_ABILITY_VALUES[speciesName + ' w/ ' + abilityName])
    return SPECIES_WITH_ABILITY_VALUES[speciesName + ' w/ ' + abilityName];

  let multiplier = 1;

  if (SPECIES_VALUES[speciesName])
    multiplier *= SPECIES_VALUES[speciesName];

  if (ABILITY_VALUES[abilityName])
    multiplier *= ABILITY_VALUES[abilityName];
  else
    multiplier *= BASE_ABILITY_VALUE;

  return multiplier;
}
function getLevel(species, statTotalGoal) {
  let prevStatTotal = Number.NEGATIVE_INFINITY;
  for (let level = 1; level <= 100; level++) {
    const statTotal = getStatTotal(species, level);
    if (statTotal > statTotalGoal) {
      if (statTotalGoal - prevStatTotal < statTotal - statTotalGoal)
        return level-1;
      else
        return level;
    }
    prevStatTotal = statTotal;
  }
  return 100;
}

function getSpeciesIdOfPokemon(pokemonStr) {
  return getSpeciesId(getSpeciesNameOfPokemon(pokemonStr));
}
function getSpeciesNameOfPokemon(pokemonStr) {
  let firstLine = pokemonStr.split('\n')[0].trimEnd();
  let name = getApparentSpeciesNameOfPokemon(pokemonStr);
  if (firstLine.includes(' @ ')) {
    let heldItem = firstLine.split(' @ ')[1];
    if (FAKE_REQUIRED_ITEMS.includes(heldItem)
          || (name === 'Arceus' && getAbilityNameOfPokemon(pokemonStr) !== 'Multitype')
          || (name === 'Silvally' && getAbilityNameOfPokemon(pokemonStr) !== 'RKS System'))
      return name;
    let holdingItemForme = Object.values(allSpecies).find(species => species.baseSpecies === name && 
                      (species.requiredItem === heldItem || species.requiredItems?.includes(heldItem)));
    if (heldItem === 'Ultranecrozium Z')
      if (name === 'Necrozma-Dusk-Mane' || name === 'Necrozma-Dawn-Wings')
        name = 'Necrozma-Ultra';
      else
        holdingItemForme = null;
    if (holdingItemForme)
      name = holdingItemForme.name;
  }
  return name;
}
function getApparentSpeciesNameOfPokemon(pokemonStr) {
  let firstLine = pokemonStr.split('\n')[0].trimEnd();
  let name = firstLine;
  if (name.includes(' @'))
    name = name.substring(0, name.indexOf(' @'));
  if (name.includes(' ('))
    name = name.substring(0, name.indexOf(' ('));
  return name;
}

function pokemonInHTML(pokemonStr) {
  const strLines = pokemonStr.split('\n');
  out = '';

  const speciesId = getSpeciesIdOfPokemon(pokemonStr);
  const species = allSpecies[speciesId];

  let heldItem;

  for (let i = 0; i < strLines.length; i++) {
    let strLine = strLines[i].trimEnd();

    if (i === 0) {
      let firstLine = strLine;
      if (strLine.includes(' @ ')) {
        strLineSplit = strLine.split(' @ ');
        heldItem = heldItems[getHeldItemId(strLineSplit[1])];
        firstLine = strLineSplit[0] + ' @ ' + heldItemInHTML(strLineSplit[1]);
      }
      const speciesName = getApparentSpeciesNameOfPokemon(pokemonStr);
      if (SPECIES_WITH_DESC[speciesName])
        firstLine = firstLine.replace(speciesName, spanWithTitle(speciesName, SPECIES_WITH_DESC[speciesName]));
      out += firstLine;
    } else if (strLine.startsWith('Ability:')) {
      out += spanWithClass('Ability: ', 'attr');
      out += abilityInHTML(strLine.substring('Ability: '.length));
      
    } else if (strLine.startsWith('Level: ')) {
      const splitBySpace = strLine.split(' ');
      splitBySpace.shift(); // remove 'Level:'
      const level = parseInt(splitBySpace.shift());
      const remainder = splitBySpace.map(str => ' ' + str).join('');
      if (level === getLevel(species, STAT_TOTAL_GOAL))
        out += spanWithClass(strLine, 'gray');
      else {
        out += spanWithClass('Level: ', 'attr') + level;
        if (remainder != null && remainder != '')
         out += spanWithClass(remainder, 'gray');
      }
      
    } else if (strLine.startsWith('Shiny:')) {
      out += spanWithClass(strLine, 'gray');

    } else if (strLine.startsWith('Tera Type:')) {
      const teraType = strLine.substring('Tera Type: '.length);
      if (forcedTera(species)) {
        out += spanWithClass('Tera Type: ', 'attr')
          + spanWithTitle(spanWithClass(teraType, 'attr strikethrough'),
              'Tera type becomes ' + forcedTera(species) + ' during battle.');
      } else if (!canTera(species, heldItem, teraType)) {
        out += spanWithClass(strLine, 'gray');
      } else {
        out += spanWithClass('Tera Type: ', 'attr');
        out += spanWithType(teraType, teraType);
      }

    } else if (strLine.startsWith('EVs: ')) {
      if (strLine === 'EVs: 1 HP') {
        out += spanWithClass(strLine, 'gray');
      } else {
        out += spanWithClass('EVs: ', 'attr');
        const statStrs = strLine.substring('EVs: '.length).split('/');
        for (const statStr of statStrs) {
          const splitBySpace = statStr.trim().split(' ');
          const statNum = parseInt(splitBySpace[0]);
          const stat = splitBySpace[1];
          if (statNum < 4)
            out += spanWithClass(statStr, 'gray') + '/';
          else
            out += spanWithClass(statStr, 'stat-' + stat.toLowerCase()) + '/';
        }
        out = out.slice(0, -1);
      }

    } else if (strLine.endsWith(' Nature')) {
      const nature = strLine.slice(0, -1 * ' Nature'.length);
      const raisedStat = STATS[NATURES[nature][0]];
      const loweredStat = STATS[NATURES[nature][1]];
      const titleText = '+' + raisedStat + ', -' + loweredStat;
      out += spanWithTitle(nature, titleText) + ' Nature';

    } else if (strLine.startsWith('-')) {
      const moveName = strLine.substring('- '.length);
      if (moveName === '')
        out += spanWithClass('- ', 'attr');
      else
        out += moveInHTML(moveName, '- ');
    } else {
      out += strLine;
    }
    out += '\n';
  }

  return out.slice(0, -1);
}
function moveInHTML(moveName, prefix) {
  if (prefix === undefined)
    prefix = '';

  const move = moves[getMoveId(moveName)];
  const type = move.type;

  let moveSpan = spanWithTitle(moveName, moveDesc(move));
  if (IMPROVED_MOVES[moveName] || MONEY_MOVES.includes(moveName))
    moveSpan = spanWithClass(moveSpan, 'improvedMove');
  return spanWithType(prefix + moveSpan, type);
}
function moveDesc(move, shortened) {
  let title = 'Type: ' + move.type + '\nCat: ' + move.category;
  if (move.basePower && move.basePower !== 0)
    title += '\nPow: ' + move.basePower;
  if (move.accuracy && move.accuracy !== true)
    title += '\nAcc: ' + move.accuracy;
  if (move.pp === 1)
    title += '\nPP: 1';

  let shortDesc = move.shortDesc;
  if (move.name.startsWith('Hidden Power')) {
    shortDesc = "A Pokemon can only know 1 Hidden Power at a time.";
    if (isCamomons())
      shortDesc += '\n\nNOTE: counts as Normal-type for Camomons.';
  }
  shortDesc = shortDesc.replace('Base move affects power. ', '');
  if (MONEY_MOVES.includes(move.name))
    shortDesc += '\nOnce per round, earn $' + MONEY_MOVE_INCOME + ' if successfully used.';
  else if (IMPROVED_MOVES[move.name])
    shortDesc = IMPROVED_MOVES[move.name];

  if (!shortened)
    title += '\n';
  title += '\n' + shortDesc;

  return title;
}

function pokemonCanTera(pokemonStr) {
  const species = allSpecies[getSpeciesIdOfPokemon(pokemonStr)];
  const heldItem = heldItems[getHeldItemId(pokemonStr.split('\n')[0].split(' @ ')[1])];
  const teraType = getTeraTypeOfPokemon(pokemonStr);
  return canTera(species, heldItem, teraType);
}
function canTera(species, heldItem, teraType) {
  // if (species.forme && 
  //   (species.forme.includes('Mega') || species.forme === 'Primal' || species.forme === 'Ultra'))
  //   return false;
  if (isOgerpon(species) && teraType && !OGERPON_TERA_TYPES.includes(teraType))
    return false;
  if (heldItem) {
    if (heldItem.name.endsWith(' Z'))
      return false;
    if ((heldItem.desc.includes('Mega Evolve') || heldItem.desc.includes('Primal Reversion'))
          && species.baseSpecies != null && heldItem.desc.includes(species.baseSpecies))
      return false;
  }
  return true;
}

function pokemonForcedTera(pokemonStr) {
  const species = allSpecies[getSpeciesIdOfPokemon(pokemonStr)];
  return forcedTera(species);
}
function forcedTera(species) {
  return species.forceTeraType;
}

function statsInHTML(statRelevantInfo, hasColor) {
  const species = statRelevantInfo[0];

  let out = '';
  for (const stat of STATS) {
    const statNum = getStat(...statRelevantInfo, stat);
    let statStr = statNum + ' ' + stat;
    if (stat === 'Atk' || stat === 'SpA')
      statStr = spanWithTitle(statStr, 'Unadjusted ' + stat + ': ' + getUnadjustedStat(...statRelevantInfo, stat));
    out += spanWithClass(' '.repeat(Math.max(0, 3-(statNum+'').length)) + statStr, hasColor ? 'stat-' + stat.toLowerCase() : '') + ' ';
    if (stat === 'Def')
      out += '\n' + ' '.repeat('... HP '.length);
  }
  out = out.slice(0, -1);

  const statTotal = getStatTotal(...statRelevantInfo);
  let statTotalStr = '';
  if (!hasColor)
    statTotalStr += 'TOTAL: ' + statTotal;
  else if (statTotal === getStatTotal(species, getLevel(species, STAT_TOTAL_GOAL)))
    statTotalStr += spanWithClass('TOTAL: ' + statTotal, 'gray');
  else
    statTotalStr += spanWithClass('TOTAL: ', 'attr') + statTotal;
  out = statTotalStr + '\n' + out;

  return out;
}

function getEvs(evsStr) {
  if (!evsStr)
    return Array(STATS.length).fill(252);
  const evs = Array(STATS.length).fill(0);
  for (let i = 0; i < STATS.length; i++) {
    const stat = STATS[i];
    if (evsStr.includes(stat)) {
      const evsStrUpToEv = evsStr.substring(0, evsStr.indexOf(stat) - 1);
      evs[i] = parseInt(evsStrUpToEv.substring(evsStrUpToEv.lastIndexOf(' ') + 1));
    }
  }
  return evs;
}
function getEvsStr(evs) {
  let evsStr = 'EVs: ';
  for (let i = 0; i < STATS.length; i++) {
    if (evs[i] !== 0)
      evsStr += evs[i] + ' ' + STATS[i] + ' / ';
  }
  if (evsStr === 'EVs: ')
    throw new Error('Invalid EVs!');
  return evsStr.slice(0, -3);  
}

function getStatRelevantInfo(pokemonStr) {
  const speciesId = getSpeciesIdOfPokemon(pokemonStr);
  const species = allSpecies[speciesId];
  const strLines = pokemonStr.split('\n');

  const level = getLevelOfPokemon(pokemonStr);

  const evsStr = pokemonStr.split('\n').find(line => line.startsWith('EVs: '));
  const evs = getEvs(evsStr);

  const nature = strLines.find(line => line.trim().endsWith(' Nature'))?.slice(0, -1 * ' Nature'.length);

  return [species, level, evs, nature];
}

function getEffectiveStatTotal(species, level, evs, nature, abilityName) {
  const abilityValue = getAbilityValue(species, abilityName);
  return getStatTotal(species, level, evs, nature) * abilityValue;
}
function getStatTotal(species, level, evs, nature) {
  let statTotal = 0;
  for (const stat of STATS)
    statTotal += getStat(species, level, evs, nature, stat);
  return statTotal;
}
function getStat(species, level, evs, nature, stat) {
  const actualStat = getUnadjustedStat(species, level, evs, nature, stat);
  if (stat === 'Atk' || stat === 'SpA')
    return Math.round(actualStat * (2*level/5 + 2)/22);
  return actualStat;
}
function getUnadjustedStat(species, level, evs, nature, stat) {
  const baseStat = species.baseStats[stat.toLowerCase()];

  const ev = evs ? evs[STATS.indexOf(stat)] : 0;

  if (stat === 'HP') {
    if (species.name === 'Shedinja')
    return 1;
    else
    return Math.floor((2*baseStat + 31 + Math.floor(ev/4)) * level/100) + level + 10;
  } else {
    const raisedStat = nature ? STATS[NATURES[nature][0]] : '';
    const loweredStat = nature ? STATS[NATURES[nature][1]] : '';
    let multiplier = 1;
    if (stat === raisedStat)
      multiplier += .1;
    if (stat === loweredStat)
      multiplier -= .1;
    return Math.floor((Math.floor((2*baseStat + 31 + Math.floor(ev/4)) * level/100) + 5) * multiplier);
  }
}

function spanWithType(str, type) {
  return spanWithClass(str, 'type-' + type.toLowerCase());
}
function spanWithClass(str, class_) {
  return '<span class="' + class_ + '">' + str + '</span>';
}
function spanWithTitle(str, title) {
  title = title.replaceAll('"', '&quot;');
  return '<span class="hasHoverText" title="' + title + '">' + str + '</span>';
}

function skipPokemonChoice() {
  const choicesDiv = document.getElementById('choices');
  killAllChildren(choicesDiv);
  endPokemonChoosing(null);
  document.getElementById('skip').hidden = true;
}

function choosePokemon(choicesDiv, pokemonStr) {
  const pokeDiv = getEmptyPartyDiv();
  if (!pokeDiv) {
    alert('Your party is full! Delete a Pokemon, or skip getting a new one.\n'
            + 'NOTE: you may NOT replace a Pokemon you got at Lv1.');
    return;
  }

  if (isBoss() && getPartyStrs().length === 0) {
    // calculate bossLevelUps
    const species = allSpecies[getSpeciesIdOfPokemon(pokemonStr)];
    const abilityName = getAbilityNameOfPokemon(pokemonStr);
    bossLevelUps = getBossLevelUps(species, abilityName);
    updateBossLevelUps();
  }

  document.getElementById('skip').hidden = true;
  
  pokeDiv.classList.add('chosen');
  
  if (pokemonStr.includes('\n- '))
    pokemonStr = pokemonStr.replace('\n- ', '\n- '.repeat(4) + '\n- ');
  else
    pokemonStr += '\n- '.repeat(4) + '\n';
  getPokeEle(pokeDiv).innerText = pokemonStr;
  
  updatePartyPokemonDiv(pokeDiv);

  if (!isBoss())
    document.getElementById('tmSeeker').selectedIndex = getPartyPokeDivs().indexOf(pokeDiv);
  else if (isBoss() && getPartyStrs().length === 1)
    document.getElementById('tmSeeker').selectedIndex = 0;
  
  killAllChildren(choicesDiv);
  
  beginAddMoveChoices(choicesDiv, pokeDiv, pokemonStr);
}
function addTeraChoice(choicesDiv, pokeDiv, typeChoices) {
  let type = removeRandom(typeChoices);

  const teraChoiceDiv = document.createElement('div');
  teraChoiceDiv.classList.add('flex-col');

  const teraChoiceEle = document.createElement('p');
  teraChoiceEle.classList.add('info-box', 'tera-choice', 'flex-center');
  const teraChoiceMatchups = document.createElement('div');
  teraChoiceMatchups.classList.add('overlay', 'tera-type');
  teraChoiceMatchups.innerHTML = getTypesHTML([type], false);
  teraChoiceEle.append(teraChoiceMatchups);
  const teraChoiceImg = document.createElement('img');
  teraChoiceImg.src = 'https://play.pokemonshowdown.com/sprites/types/Tera' + type + '.png';
  teraChoiceEle.append(teraChoiceImg);

  const teraChoiceButton = document.createElement('button');
  teraChoiceButton.innerText = 'choose';
  teraChoiceButton.onclick = function() {chooseTera(choicesDiv, pokeDiv, type)};

  teraChoiceDiv.append(teraChoiceEle, teraChoiceButton);
  choicesDiv.append(teraChoiceDiv);
}
function chooseTera(choicesDiv, pokeDiv, type) {
  const pokeEle = getPokeEle(pokeDiv);
  let pokemonStr = pokeEle.innerText;
  pokemonStr = pokemonStr.replace(getTeraTypeLineOfPokemon(pokemonStr), 'Tera Type: ' + type);
  pokeEle.innerHTML = pokemonInHTML(pokemonStr);
  updatePokemonDiv(pokeDiv);

  killAllChildren(choicesDiv);

  endPokemonChoosing(pokeDiv);
}
function beginAddMoveChoices(choicesDiv, pokeDiv, pokemonStr) {
  const speciesId = getSpeciesIdOfPokemon(pokemonStr);
  let moveIds;
  if (getPokeball() === 'Strange Ball')
    moveIds = allMoveIdsSuchThat(move => isLegalMove(move, false, false));
  else
    moveIds = getLearnset(speciesId);
  moveIds = moveIds.filter(moveId => {
    const move = moves[moveId];
    return !(pokemonHasMove(pokemonStr, move.name) || isLGPE(move) || isZ(move));
  });
  addMoveChoices(choicesDiv, pokeDiv, speciesId, moveIds);
}
function addMoveChoices(choicesDiv, pokeDiv, speciesId, moveIds) {
  for (let i = 0; i < numChoices(); i++)
    addMoveChoice(choicesDiv, pokeDiv, speciesId, moveIds);
}
function addMoveChoice(choicesDiv, pokeDiv, speciesId, moveIds) {
  let move;
  if (moveIds.length === 0) {
    const pokemonStr = getPokeEle(pokeDiv).innerText;
    do {
      move = randomMove(false);
    } while (pokemonHasMove(pokemonStr, move.name) || isLGPE(move) || isZ(move));
  } else 
    move = addHiddenPowerType(moves[removeRandom(moveIds)]);

  const choiceDiv = document.createElement('div');
  choiceDiv.classList.add('flex-col');

  const choiceEle = document.createElement('p');
  choiceEle.classList.add('info-box', 'move-choice');
  choiceEle.innerHTML = spanWithClass(spanWithType(move.name, move.type), 'big-text') + '\n' + moveDesc(move);

  const choiceButton = document.createElement('button');
  choiceButton.innerText = 'choose';
  choiceButton.onclick = function() {chooseMove(choicesDiv, pokeDiv, speciesId, moveIds, move)};

  choiceDiv.append(choiceEle, choiceButton);
  choicesDiv.append(choiceDiv);
}
function chooseMove(choicesDiv, pokeDiv, speciesId, moveIds, move) {
  const pokeEle = getPokeEle(pokeDiv);
  const pokemonStr = pokeEle.innerText.replace('\n- \n', '\n- ' + move.name + '\n');
  pokeEle.innerHTML = pokemonInHTML(pokemonStr);
  updatePokemonDiv(pokeDiv);

  killAllChildren(choicesDiv);

  prevSeenItems.add(speciesTM(allSpecies[speciesId].name, move).name);

  if (pokemonStr.includes('\n- \n')) {
    addMoveChoices(choicesDiv, pokeDiv, speciesId, moveIds);
  } else {
    pokeEle.innerHTML = pokeEle.innerHTML.slice(0, -1); // remove the extra \n at the end
    const species = allSpecies[getSpeciesIdOfPokemon(pokemonStr)];
    if (canTera(species) && !pokemonForcedTera(pokemonStr)) {
      let typeChoices = TERA_TYPES.slice();
      if (isOgerpon(species))
        typeChoices = OGERPON_TERA_TYPES.slice();

      for (let i = 0; i < numChoices() && typeChoices.length > 0; i++)
        addTeraChoice(choicesDiv, pokeDiv, typeChoices);
    } else {
      endPokemonChoosing(pokeDiv);
    }
  }
}

function getBossLevelUps(species, abilityName) {
  let levelUps = [];
  let prevLevel = getLevelWithAbility(species, abilityName);
  for (let i = 2; i <= (startingNumSlots ?? getPartyPokeDivs().length); i++) {
    const nextLevel = getLevelWithAbility(species, abilityName, Math.pow(i, 1/4));
    levelUps.push(nextLevel - prevLevel);
    prevLevel = nextLevel;
  }
  return levelUps;
}

function endPokemonChoosing(pokeDiv) {
  if (pokeDiv != null)
    pokeDiv.classList.remove('chosen');
  resetRoundBasedInputs();
  toggleNonPokemonChoices(true);
}
function resetRoundBasedInputs() {
  document.getElementById('pokeball').selectedIndex = 0;
  // document.getElementById('pokeballDiv').hidden = true;
  updatePokeballDesc('Poke Ball');

  const lastMagnetType = getKeyItems().map(item => getMagnetType(item)).findLast(type => type != null);
  if (lastMagnetType == null)
    document.getElementById('type').selectedIndex = 0;
  else
    setGuaranteedType(lastMagnetType);

  document.getElementById('extraIncome').checked = false;
  document.getElementById('won').checked = false;
}

function updateRefreshCost() {
  let refreshCost = BASE_REFRESH_COST;
  if (numPokemonWithAbility('Run Away') > 0)
    refreshCost = RUN_AWAY_REFRESH_COST;
  if (numOfKeyItem(KEY_ITEMS.CHEAP_REFRESH) > 0)
    refreshCost = 2;
  document.getElementById('refresh').textContent = '$' + refreshCost + ' - refresh';
}
function updateTMSeekerOptions() {
  const tmSeekerEle = document.getElementById('tmSeeker');
  const index = tmSeekerEle.selectedIndex;
  killAllChildren(tmSeekerEle);
  const speciesNames = getPartyStrs().map(pokemonStr => getApparentSpeciesNameOfPokemon(pokemonStr));
  for (let i = 0; i < speciesNames.length; i++) {
    const option = document.createElement('option');
    option.innerText = speciesNames[i];
    tmSeekerEle.append(option);
  }
  const numOptions = tmSeekerEle.length;
  if (index < numOptions)
    tmSeekerEle.selectedIndex = index;
  else
    tmSeekerEle.selectedIndex = numOptions-1;
}

function numPokemonWithAbility(abilityName) {
  return getPartyStrs().filter(pokemonStr => getAbilityNameOfPokemon(pokemonStr) === abilityName).length;
}

function toggleNonPokemonChoices(turnOn) {
  const ELEMENT_IDS = ['save', 'load', 'pokeball', 'type', 'extraIncome', 'won', 'nextRound', 'tmSeeker', 'refresh'];
  for (const elementId of ELEMENT_IDS)
    toggleEle(document.getElementById(elementId), turnOn);
  const shopDivs = document.getElementById('shop').children;
  for (const shopDiv of shopDivs) {
    toggleEle(shopDiv.querySelector('input'), turnOn);
    toggleEle(shopDiv.querySelector('button'), turnOn);
  }
}
function toggleAfterFirstRoundChoices(turnOn) {
  const ELEMENT_IDS = ['extraIncome', 'won', 'tmSeeker', 'refresh'];
  for (const elementId of ELEMENT_IDS)
    toggleEle(document.getElementById(elementId), turnOn);
}
function toggleEle(ele, turnOn) {
  if (ele)
    ele.disabled = !turnOn;
}

function removeRandom(arr) {
  const index = randomInt(arr.length);
  const out = arr[index];
  arr.splice(index, 1);
  return out;
}

function getEmptyPartyDiv() {
  for (const partyPokeDiv of getPartyPokeDivs()) {
    const partyPokeEle = getPokeEle(partyPokeDiv);
    if (partyPokeEle.innerText.trim() === '') {
      return partyPokeDiv;
    }
  }
  return null;
}

function getPartyStrs(includeEmptyStrs) {
  let partyStrs = getPartyPokeEles().map(pokeEle => pokeEle.innerText.trim());
  if (!includeEmptyStrs)
    partyStrs = partyStrs.filter(str => str !== '');
  return partyStrs;
}

function getPokeEle(pokeDiv) {
  return pokeDiv.querySelector('.pokemon');
}

function getPartyPokeEles() {
  return getPartyPokeDivs().map(pokeDiv => getPokeEle(pokeDiv));
}
function getPartyPokeDivs() {
  const partyDiv = document.getElementById('party');
  return Array.from(partyDiv.querySelectorAll('.pokemon-div'));
}

function copyParty() {
  const partyStrs = getPartyStrs();

  // handle MAGIKARP key item
  for (let i = 0; i < numOfKeyItem(KEY_ITEMS.MAGIKARP); i++)
    partyStrs.push(randomLv1Magikarp().slice(0, -1 * '\n- \n- \n-'.length));

  copyStr(partyStrs.join('\n\n'));
}
function copyStr(str) {
  navigator.clipboard.writeText(str);
}

function randomLv1Magikarp() {
  return randomOfSpecies('Magikarp', null, null, 1, 'random', true, false)
        +  '\n- Splash\n- \n- \n-';
}

function save() {
  const partyStrs = getPartyStrs(true);
  if (partyStrs.length === 0) {
    alert('No party Pokemon to save!');
    return;
  }

  localStorage.setItem('partySize', getPartyPokeDivs().length);

  localStorage.setItem('partyStrs', partyStrs.join('\n\n'));

  localStorage.setItem('money', getMoneyStr());

  localStorage.setItem('pokeball', getPokeball());
  localStorage.setItem('pokeballHidden', document.getElementById('pokeballDiv').hidden);
  localStorage.setItem('type', getGuaranteedType());
  localStorage.setItem('typeHidden', document.getElementById('pokeballDiv').hidden);

  localStorage.setItem('extraIncome', document.getElementById('extraIncome').checked);
  localStorage.setItem('won', document.getElementById('won').checked);

  localStorage.setItem('winCounter', document.getElementById('winCounter').textContent);

  localStorage.setItem('roundCounter', roundCounter);
  localStorage.setItem('numRounds', getNumRounds());
  localStorage.setItem('endless', document.getElementById('endless').checked);
  localStorage.setItem('camomons', document.getElementById('camomons').checked);

  if (!isBoss())
    localStorage.removeItem('bossLevelUps');
  else
    localStorage.setItem('bossLevelUps', bossLevelUps.join(','));

  localStorage.setItem('vsBossBattle', isVsBoss());

  localStorage.setItem('tmSeeker', document.getElementById('tmSeeker').value);

  localStorage.setItem('beforeBattle', document.getElementById('beforeBattle').innerHTML);
  localStorage.setItem('nextBattle', document.getElementById('nextBattle').innerHTML);

  localStorage.setItem('keyItems', document.getElementById('keyItems').innerHTML);

  localStorage.setItem('startingNumSlots', startingNumSlots);

  removeEventListener("beforeunload", beforeUnloadListener, { capture: true });
}
function load() {
  if (getPartyStrs().length > 0) {
    alert('Cannot load over existing party Pokemon.');
    return;
  }

  // needs to happen before updatePartyPokemonDiv, so that types are displayed correctly
  document.getElementById('camomons').checked = localStorage.getItem('camomons') === 'true';

  const partySize = parseInt(localStorage.getItem('partySize'));
  setPartySize(partySize);

  const partyStrs = localStorage.getItem('partyStrs').split('\n\n');
  for (const pokeEle of getPartyPokeEles()) {
    const pokemonStr = partyStrs.shift();
    pokeEle.textContent = pokemonStr;
    if (pokemonStr.includes(' @ Dubious Disc'))
      removeEditable(pokeEle);
    updatePartyPokemonDiv(pokeEle.parentElement);
  }

  setMoney(localStorage.getItem('money'));

  setPokeball(localStorage.getItem('pokeball'));
  document.getElementById('pokeballDiv').hidden = localStorage.getItem('pokeballHidden') === 'true';
  setGuaranteedType(localStorage.getItem('type'));

  document.getElementById('extraIncome').checked = localStorage.getItem('extraIncome') === 'true';
  document.getElementById('won').checked = localStorage.getItem('won') === 'true';
  
  document.getElementById('winCounter').textContent = localStorage.getItem('winCounter');
  
  setRoundCounter(parseInt(localStorage.getItem('roundCounter')));
  setNumRounds(localStorage.getItem('numRounds'));
  document.getElementById('endless').checked = localStorage.getItem('endless') === 'true';
  
  if (isCamomons()) {
    const commandEle = document.getElementById('camomonsCommand');
    commandEle.hidden = false;
    if (getPartyStrs().length >= 2)
      commandEle.innerText = CAMOMONS_DOUBLES_COMMAND;
  }

  const bossLevelUpsStr = localStorage.getItem('bossLevelUps');
  const bossBattleCheckbox = document.getElementById('bossBattle');
  if (bossLevelUpsStr == null) {
    bossLevelUps = null;
    bossBattleCheckbox.checked = false;
    document.getElementById('bossLevelUps').textContent = '';
  } else {
    bossLevelUps = bossLevelUpsStr.split(',').map(str => parseInt(str));
    bossBattleCheckbox.checked = true;
    updateBossLevelUps();
  }
  
  const vsBossBattleCheckbox = document.getElementById('vsBossBattle');
  vsBossBattleCheckbox.checked = localStorage.getItem('vsBossBattle') === 'true';

  bossBattleCheckbox.disabled = true;
  vsBossBattleCheckbox.disabled = true;
  
  document.getElementById('tmSeeker').value = localStorage.getItem('tmSeeker');

  const beforeBattleHTML = localStorage.getItem('beforeBattle');
  document.getElementById('beforeBattleDiv').hidden = beforeBattleHTML === '';
  document.getElementById('beforeBattle').innerHTML = beforeBattleHTML;
  const nextBattleHTML = localStorage.getItem('nextBattle');
  document.getElementById('nextBattleDiv').hidden = nextBattleHTML === '';
  document.getElementById('nextBattle').innerHTML = nextBattleHTML;

  const keyItemsHTML = localStorage.getItem('keyItems');
  if (keyItemsHTML != null) {
    document.getElementById('keyItemsDiv').hidden = keyItemsHTML === '';
    document.getElementById('keyItems').innerHTML = keyItemsHTML;
    updateKeyItemsEle();
  }

  const startingNumSlotsStr = localStorage.getItem('startingNumSlots');
  if (startingNumSlotsStr != null)
    startingNumSlots = parseInt(startingNumSlotsStr);

  toggleAfterFirstRoundChoices(true);

  removeEventListener("beforeunload", beforeUnloadListener, { capture: true });
}

function nextRound() {
  const prevMoney = getMoney();
  if (prevMoney == null)
    return;
  let income = INCOME;
  if (document.getElementById('extraIncome').checked)
    income += MONEY_MOVE_INCOME;
  const won = document.getElementById('won').checked;
  if (won)
    income += WIN_INCOME_DELTA;
  income -= getTax(prevMoney);
  income += 30 * numOfKeyItem(KEY_ITEMS.INVESTMENT) - 30 * numOfKeyItem(KEY_ITEMS.LOAN);
  setMoney(prevMoney + income);

  const choicesDiv = document.getElementById('choices');
  killAllChildren(choicesDiv);
  const addChoicesSuccessful = addChoices(choicesDiv);
  if (!addChoicesSuccessful) {
    setMoney(prevMoney);
    return;
  }
  toggleNonPokemonChoices(false);
  
  const isPartyFull = getEmptyPartyDiv() === null;
  document.getElementById('skip').hidden = !isPartyFull;

  document.getElementById('beforeBattleDiv').hidden = true;
  document.getElementById('beforeBattle').innerHTML = '';
  document.getElementById('nextBattleDiv').hidden = true;
  document.getElementById('nextBattle').innerHTML = '';

  if (won)
    document.getElementById('winCounter').textContent += '‚úì ';

  if (roundCounter === 0) {
    startingNumSlots = getPartyPokeDivs().length;

    document.getElementById('bossBattle').disabled = true;
    document.getElementById('vsBossBattle').disabled = true;
  }

  if (getPartyStrs().length + 1 >= 2)
    document.getElementById('camomonsCommand').innerText = CAMOMONS_DOUBLES_COMMAND;

  // NOTE: For roundly events, there may be some minor interactions, so make it happen in order
  // of how they'd be read on the website.
  
  // handle boss level ups & extra move slots
  if (bossLevelUps != null) {
    const pokeDiv = getPartyPokeDivs()[0];
    const pokeEle = getPokeEle(pokeDiv);

    let pokemonStr = pokeEle.innerText.trim();
    if (bossLevelUps.length > 0) {
      const levelDelta = bossLevelUps.shift();
      updateBossLevelUps();
      pokemonStr = leveledUp(pokemonStr, levelDelta);

      pokemonStr += '\n-';
    }

    pokeEle.innerText = pokemonStr;
    updatePartyPokemonDiv(pokeDiv);
  }

  // handle held items that happen every round: Power items (Power Anklet, etc), Oval Stone, and type stones
  for (const pokeDiv of getPartyPokeDivs()) {
    const pokeEle = getPokeEle(pokeDiv);
    const pokemonStr = pokeEle.innerText.trim();
    let updatedPokemonStr = updateForRoundlyHeldItem(pokemonStr);
    if (updatedPokemonStr != null) {
      pokeEle.innerText = updatedPokemonStr;
      updatePartyPokemonDiv(pokeDiv);
    }
  }

  // remove single-round key items
  const keyItemsEle = document.getElementById('keyItems');
  const lines = keyItemsEle.innerText.split('\n');
  for (let i = 0; i < lines.length; i++) {
    lines[i] = lines[i].trim();
    if (ALL_SLOTS_KEY_ITEMS.includes(lines[i]))
      lines[i] += ' (Used)';
  }
  keyItemsEle.innerText = lines.join('\n');
  updateKeyItemsEle();

  // handle Roundly Key Items
  for (const keyItem of getKeyItems()) {
    switch (keyItem) {
      case KEY_ITEMS.ROUNDLY_MAGIKARP:
        if (addPartySlot()) {
          const pokeDiv = getPartyPokeDivs().pop();
          getPokeEle(pokeDiv).innerText = randomLv1Magikarp();
          updatePartyPokemonDiv(pokeDiv);
        }
        break;

      case KEY_ITEMS.LV_UP_HIGHEST:
        levelUpExtremes(true);
        break;
      
      case KEY_ITEMS.LV_UP_LOWEST:
        levelUpExtremes(false);
        break;

      case KEY_ITEMS.LV_UP_RANDOM:
        let partyIndex = randomInt(getPartyStrs().length);
        for (const pokeDiv of getPartyPokeDivs()) {
          const pokeEle = getPokeEle(pokeDiv);
          const pokemonStr = pokeEle.innerText.trim();
          if (pokemonStr !== '') {
            if (partyIndex === 0) {
              pokeEle.innerText = leveledUp(pokemonStr);
              updatePartyPokemonDiv(pokeDiv);
              break;
            }
            partyIndex--;
          }
        }
        break;

      default:
        // NORMAL_LV_UP, etc
        for (const type of TYPES) {
          if (keyItem === KEY_ITEMS[type.toUpperCase() + '_LV_UP']) {
            for (const pokeDiv of getPartyPokeDivs()) {
              const pokeEle = getPokeEle(pokeDiv);
              const pokemonStr = pokeEle.innerText.trim();
              if (pokemonStr !== '' && getTypesOfPokemon(pokemonStr).includes(type)) {
                pokeEle.innerText = leveledUp(pokemonStr);
                updatePartyPokemonDiv(pokeDiv);
              }
            }
            break;
          }
        }
    }
  }

  setRoundCounter(roundCounter+1);
  if (document.getElementById('endless').checked) {
    const numRounds = getNumRounds();
    if (roundCounter >= numRounds)
      setNumRounds(roundCounter + 1);
  }
}
function updateForRoundlyHeldItem(pokemonStr) {
  // Power items
  for (let i = 0; i < POWER_ITEMS.length; i++) {
    if (pokemonStr.includes(' @ ' + POWER_ITEMS[i])) {
      const evsStr = pokemonStr.split('\n').find(line => line.startsWith('EVs: '));
      if (evsStr) {
        const evs = getEvs(evsStr);
        evs[i] = Math.max(evs[i], Math.min(evs[i] + POWER_ITEM_DELTA, 252, 508 - (sumArr(evs) - evs[i]))); 
        return pokemonStr.replace(evsStr, getEvsStr(evs));
      }
    }
  }
  // Oval Stone
  if (pokemonStr.includes(' @ Oval Stone'))
    return leveledUp(pokemonStr);
  // Up-Grade
  if (pokemonStr.includes(' @ Up-Grade')) {
    const apparentPrevSpeciesName = getApparentSpeciesNameOfPokemon(pokemonStr);
    const newSpeciesInfo = randomTransformedSpeciesForPokemon(pokemonStr, UP_GRADE_MIN_DIFF, UP_GRADE_MAX_DIFF);
    if (newSpeciesInfo === null)
      return null;
    return pokemonStr.replace(apparentPrevSpeciesName, newSpeciesInfo.speciesName);
  }
  // Type Stones
  for (const [stoneName, type] of Object.entries(TYPE_STONES)) {
    if (pokemonStr.includes(' @ ' + stoneName))
      return addRandomMoveSuchThat(pokemonStr, move => move.type === type);
  }
  // Sun/Moon Stone
  if (pokemonStr.includes(' @ Sun Stone'))
    return addRandomMoveSuchThat(pokemonStr, move => move.priority != null && move.priority > 0);
  if (pokemonStr.includes(' @ Moon Stone'))
    return addRandomMoveSuchThat(pokemonStr, move => move.priority != null && move.priority < 0);
  // Dawn Stone
  if (pokemonStr.includes(' @ Dawn Stone')) {
    const pokeStrSplit = pokemonStr.split('\n-');
    const numMoves = pokeStrSplit.length - 1;
    let newPokemonStr = pokeStrSplit[0];
    for (let i = 0; i < numMoves; i++)
      newPokemonStr = addRandomMove(newPokemonStr);
    return newPokemonStr;
  }
  // Dusk Stone
  if (pokemonStr.includes(' @ Dusk Stone')) {
    pokemonStr = leveledUp(pokemonStr);

    const pokeStrSplit = pokemonStr.split('\n-');
    const moveIndices = [];
    for (let i = 1; i < pokeStrSplit.length; i++) {
      if (pokeStrSplit[i].trim() !== '')
        moveIndices.push(i);
    }
    if (moveIndices.length === 0)
      return pokemonStr.replace('\n-', '\n- Struggle');

    const skippedIndex = randomElement(moveIndices);
    let newPokemonStr = pokeStrSplit[0];
    for (let i = 1; i < pokeStrSplit.length; i++) {
      newPokemonStr += '\n-';
      if (i !== skippedIndex)
        newPokemonStr += pokeStrSplit[i];
    }
    if (moveIndices.length === 1)
      newPokemonStr = newPokemonStr.replace('\n-', '\n- Struggle');
    return newPokemonStr;
  }
  // Big Nugget
  if (pokemonStr.includes(' @ Big Nugget'))
    pay(-30);
}

function levelUpExtremes(isMaxNotMin) {
  const partyDivs = getPartyPokeDivs();

  let extremeIndices = null;
  let extremeLv;
  for (let i = 0; i < partyDivs.length; i++) {
    const pokeStr = getPokeEle(partyDivs[i]).innerText.trim();
    if (pokeStr !== '') {
      const lv = getLevelOfPokemon(pokeStr);
      if (extremeIndices == null || (isMaxNotMin ? (lv > extremeLv) : (lv < extremeLv))) {
        extremeIndices = [i];
        extremeLv = lv;
      } else if (lv === extremeLv) {
        extremeIndices.push(i);
      }
    }
  }

  for (const i of extremeIndices) {
    const pokeDiv = partyDivs[i];
    const pokeEle = getPokeEle(pokeDiv);
    pokeEle.innerText = leveledUp(pokeEle.innerText.trim());
    updatePartyPokemonDiv(pokeDiv);
  }
}

function leveledUp(pokemonStr, levelDelta) {
  if (!levelDelta)
    levelDelta = 1;
  const lv = getLevelOfPokemon(pokemonStr);
  return pokemonStr.replace('Level: ' + lv, 'Level: ' + (lv + levelDelta));
}
function getLevelOfPokemon(pokemonStr) {
  const lvStr = pokemonStr.split('\n').find(line => line.startsWith('Level: '));
  return lvStr ? parseInt(lvStr.substring('Level: '.length)) : 100;
}

function getTeraTypeOfPokemon(pokemonStr) {
  const forcedType = pokemonForcedTera(pokemonStr);
  if (forcedType != null)
    return forcedType;

  const line = getTeraTypeLineOfPokemon(pokemonStr);
  if (line == null)
    return null;
  const type = line.substring('Tera Type: '.length).trimEnd();
  return TERA_TYPES.includes(type) ? type : null;
}
function getTeraTypeLineOfPokemon(pokemonStr) {
  return pokemonStr.split('\n').find(line => line.startsWith('Tera Type: '));
}

function pokemonHasMove(pokemonStr, moveName) {
  return (pokemonStr.includes('\n- ' + moveName + '\n') || pokemonStr.endsWith('\n- ' + moveName))
              || (moveName.startsWith('Hidden Power') && pokemonStr.includes('\n- Hidden Power'));
}

function addRandomMove(pokemonStr) {
  return addRandomMoveSuchThat(pokemonStr, move => true);
}
function addRandomMoveSuchThat(pokemonStr, movePredicate) {
  let move;
  let failsafe = 1000;
  do {
    move = randomMove(false);
    if (failsafe-- < 0)
      return pokemonStr;
  } while (!movePredicate(move) || pokemonHasMove(pokemonStr, move.name));
  return pokemonStr + '\n- ' + move.name;
}

function isStatRaising(move) {
  return Object.values(getStatBoosts(move)).some(boost => boost > 0);
}
function isStatLowering(move) {
  return Object.values(getStatBoosts(move)).some(boost => boost < 0);
}
function getStatBoosts(move) {
  return move.boosts ?? move.secondary?.boosts ?? move.self?.boosts ?? move.secondary?.self?.boosts ?? {};
}

function setRoundCounter(num) {
  roundCounter = num;
  document.getElementById('roundCounter').textContent = num;
}

function setNumRounds(num) {
  document.getElementById('numRounds').value = num;
}
function getNumRounds() {
  return parseInt(document.getElementById('numRounds').value);
}

function sumArr(arr) {
  return arr.reduce((a,b) => a+b, 0);
}

const KEY_ITEM_SHOP_FUNCS = Object.freeze({
  TM: funcWithoutRepeat(randomTM),
  ABILITIZER: funcWithoutRepeat(randomAbilitizer),
  TRANSFORMER: funcWithoutRepeat(randomTransformer),
  EGG: funcWithoutRepeat(randomEgg),
  HELD_ITEM: funcWithoutRepeat(randomHeldItem),
  NEXT_BATTLE: funcWithoutRepeat(function() {
    return randomElement(items.filter(item => isNextBattleItem(item) && getItemPrice(item) >= 0 && isLegalItem(item, true)));
  }),
  POKEBALL: function() {
    return randomElement(items.filter(item => item.type === 'pokeball' && isLegalItem(item, true)));
  },
  TERA: function() {
    let type = randomElement(TERA_TYPES);
    return items.find(item => item.name === type + ' Tera Shards');
  },
  FREE_GUARANTEED_TYPE: funcWithoutRepeat(function() {
    let type = randomElement(TYPES);
    let itemCopy = structuredClone(items.find(item => item.name === 'Encounter Power: ' + type));
    itemCopy.price = 0;
    return itemCopy;
  }),
  MAX_NUTRIENCE: function() {
    let stat = randomElement(STATS);
    return randomElement(items.filter(item => item.desc.startsWith("Set a Pokemon's " + stat + ' EV to 252')));
  },
  BERRY: function() {
    return randomHeldItem(true);
  },
  CANDY_PARTY: function() {
    let type = randomElement(TYPES);
    return items.find(item => item.name === type + ' Candy Party');
  },
  SCOUTING: function() {
    return items.find(item => item.name === 'Scouting');
  },
  MINT: function() {
    let nature;
    do {
      nature = randomElement(Object.keys(NATURES));
    } while (NATURES[nature][0] === NATURES[nature][1]); // must be non-neutral
    return items.find(item => item.name === nature + ' Mint');
  }
});
function refreshShop(isViaMoney) {
  const shopDiv = document.getElementById('shop');

  let shopSlotFuncs = [];
  const numAnySlots = Math.max(0, NUM_SHOP_OPTIONS + numOfKeyItem(KEY_ITEMS.MORE_SHOP_SLOT) - numOfKeyItem(KEY_ITEMS.LESS_SHOP_SLOT));
  pushNTimes(shopSlotFuncs, numAnySlots, funcWithoutRepeat(randomItem));
  pushNTimes(shopSlotFuncs, numPokemonWithAbility('Ball Fetch'), function() {
    return randomElement(items.filter(item => item.type === 'pokeball' && isLegalItem(item, true)));
  });
  for ([key, func] of Object.entries(KEY_ITEM_SHOP_FUNCS))
    pushNTimes(shopSlotFuncs, numOfKeyItem(KEY_ITEMS[key + '_SLOT']), func);  
  // handle TRs
  const partyStrs = getPartyStrs();
  for (let i = 0; i < partyStrs.length; i++) {
    const heldItem = getHeldItemOfPokemon(partyStrs[i]);
    if (isTR(heldItem)) {
      const moveName = getTRMoveName(heldItem);
      shopSlotFuncs.push(() => { return {
        name: 'Free Universal TM #' + heldItem.name.substring(2),
        type: 'universalTM',
        price: 0,
        desc: tmDesc(UNIVERSAL_TM_PREFIX, moves[getMoveId(moveName)])
      }})
    }
  }
  if (isCamomons())
    shopSlotFuncs.push(() => {return {
      name: 'Slot Swap',
      type: 'misc',
      price: 20,
      desc: 'Pick a pokemon. Swap any two of its move slots.',
    }});
  const AllSlotsKeyItem = getKeyItems().findLast(keyItem => ALL_SLOTS_KEY_ITEMS.includes(keyItem));
  if (AllSlotsKeyItem != null) {
    const keyItemKey = Object.keys(KEY_ITEMS).find(key => KEY_ITEMS[key] === AllSlotsKeyItem);
    const keyItemShopFuncsKey = keyItemKey.slice(0, -1 * '_ALL'.length);
    const n = shopSlotFuncs.length;
    shopSlotFuncs = [];
    pushNTimes(shopSlotFuncs, n, KEY_ITEM_SHOP_FUNCS[keyItemShopFuncsKey]);
  }

  let numItemsToAdd = shopSlotFuncs.length;
  const frozenItems = [];
  for (let i = 0, shopIndex = 0; i < shopDiv.childNodes.length; i++) {
    const itemDiv = shopDiv.childNodes[i];
    shopIndex++;
    if (itemDiv.querySelector('input').checked) {
      frozenItems[i] = itemDiv;
      if (i < shopSlotFuncs.length)
        numItemsToAdd--;
    }
  }

  if (isViaMoney) {
    if (numItemsToAdd <= 0) {
      alert('All slots that would be replaced are frozen!');
      return;
    }
    const refreshButton = document.getElementById('refresh');
    const price = parseInt(refreshButton.textContent.substring(1, refreshButton.textContent.indexOf(' ')));
    if(!pay(price)) return;
  }

  killAllChildren(shopDiv);

  for (let i = 0; i < shopSlotFuncs.length; i++) {
    if (frozenItems[i])
      shopDiv.append(frozenItems[i]);
    else
      shopDiv.append(createItemDiv(shopSlotFuncs[i]()));
  }
  for (let i = shopSlotFuncs.length; i < frozenItems.length; i++) {
    if (frozenItems[i])
      shopDiv.append(frozenItems[i]);
  }
}
function pushNTimes(arr, n, element) {
  arr.push(...Array(n).fill(element));
}

function funcWithoutRepeat(itemFunc) {
  return function() {
    const categoryRandy = itemFunc === randomItem ? Math.random() : null;
    let item;
    let failsafe = 1000;
    do {
      item = itemFunc(categoryRandy);
      if (failsafe-- < 0)
        prevSeenItems.clear();
    } while (prevSeenItems.has(item.name));
    prevSeenItems.add(item.name);
    return item;
  }
}

// categoryRandy is set outside the do-while loop so categories that are likely to give a prevSeenItem
// (such as randomTM when tmSeeker has a small learnset) don't become less likely overall
function randomItem(categoryRandy) {
  let randy = categoryRandy ?? Math.random();
  if ((randy -= 1/3) < 0) {
    if (numOfKeyItem(KEY_ITEMS.NO_TM) > 0)
      return randomItem();
    return randomTM();
  } else if ((randy -= 1/12) < 0) {
    if (numOfKeyItem(KEY_ITEMS.NO_ABILITIZER) > 0)
      return randomItem();
    return randomAbilitizer(100);
  } else if ((randy -= 1/12) < 0) {
    if (numOfKeyItem(KEY_ITEMS.NO_TRANSFORMER) > 0)
      return randomItem();
    return randomTransformer();
  } else if ((randy -= 1/24) < 0) {
    if (numOfKeyItem(KEY_ITEMS.NO_EGG) > 0)
      return randomItem();
    return randomEgg();
  } else if ((randy -= 1/6) < 0) {
    if (numOfKeyItem(KEY_ITEMS.NO_HELD_ITEM) > 0)
      return randomItem();
    return randomHeldItem();
  } else {
    return randomNonheldItem();
  }
}

function randomNonheldItem() {
  let item;
  do {
    item = randomElement(items);
  } while (!(isLegalItem(item) && item.type !== 'heldItem'));
  return item;
}
function randomHeldItem(mustBeBerry) {
  let item;
  do {
    item = randomElement(items);
  } while (!(isLegalItem(item) && item.type === 'heldItem') 
              || (mustBeBerry && !item.name.endsWith(' Berry')));

  item = structuredClone(item);
  const heldItemName = item.name;

  let randy = Math.random();
  if (mustBeBerry)
    randy = 1; // must be a regular held item
  if ((randy -= .05) < 0) {
    // held item party
    item.name += ' Party';
    item.type = 'heldItemParty';
    item.price = getItemPrice(item);
    if (item.price === 1)
      item.price = 0;
    if (fewValidHolders(item, heldItemName))
      item.price = (-1 * AVG_HELD_ITEM_VALUE) + 'n+' + (item.price + AVG_HELD_ITEM_VALUE);
    else
      item.price = (item.price - AVG_HELD_ITEM_VALUE) + 'n+' + AVG_HELD_ITEM_VALUE;
    item.desc = "Set EVERY Pokemon's held item to " + heldItemNameAndDesc(heldItemName);
  } else if ((randy -= .05) < 0 && getItemPrice(item) >= 0) {
    // twin held items
    item.name = 'Twin ' + item.name + '(s)';
    item.type = 'beforeHeldItem';
    item.price = getItemPrice(item);
    if (fewValidHolders(item, heldItemName) || heldItemName === 'Eviolite')
      item.price = slightlyLowerNonnegativePrice(item.price);
    else
      item.price = 0;
    item.desc = 'Before battle: Both players MAY give their [nth] Pokemon ' 
                    + aOrAn(heldItemName).slice(0, -1 * heldItemName.length) // just "a" or "an"
                    + heldItemNameAndDesc(heldItemName);
  } else if ((randy -= .05) < 0) {
    // binary held items
    let item2;
    do {
      item2 = randomElement(items);
    } while (!(isLegalItem(item2) && item2.type === 'heldItem') 
                || (mustBeBerry && !item2.name.endsWith(' Berry'))
                || item == item2);
    item2 = structuredClone(item2);
    const heldItemName2 = item2.name;
    
    // adjust prices
    for (const itemI of [item, item2]) {
      if (itemI.price < 0)
        itemI.price = itemI.desc; // the janky location where i put the price if applied Before Battle. see Sticky Barb, etc.
      // Note: Dubious Disc's price looks like -20r-10; it is intentionally not captured in the above case
      itemI.price = getItemPrice(itemI);
      if (itemI.price > 0) {
        const itemIName = itemI == item ? heldItemName : heldItemName2;
        if (fewValidHolders(itemI, itemIName, true))
          itemI.price = roundToNearest5(itemI.price/2, true);
        else
          itemI.price = slightlyLowerNonnegativePrice(itemI.price);
        if (itemI.price <= 0)
          itemI.price = 1;
      }
    }

    item.name = item.name + ' or ' + item2.name;
    item.type = 'beforeHeldItem';
    item.price = Math.min(item.price, item2.price);

    item.desc = "Before battle: Your opponent chooses whether you set 1 of your Pokemon's held item to " 
                    + heldItemNameInHTML(heldItemName) + ' or ' + heldItemNameInHTML(heldItemName2) + '.\n'
                    + twoEqualWidthAttr(heldItemDesc(heldItemName), heldItemDesc(heldItemName2));
    
  } else {
    // regular held item
    item.desc = "Set a Pokemon's held item to " + heldItemNameAndDesc(heldItemName);
  }

  return item;
}
function heldItemNameAndDesc(heldItemName) {
  return heldItemNameInHTML(heldItemName) + '.\n'
                + spanWithClass(heldItemDesc(heldItemName), 'attr');
}
function slightlyLowerNonnegativePrice(price) {
  if (price < 0) {
    console.err('slightlyLowerNonnegativePrice was run on price=' + price);
    return price;
  }
  return Math.max(0, Math.min(roundToNearest5(price * .8, true), price - 5));
}
function fewValidHolders(item, heldItemName, ignoreReqs) {
  return (!ignoreReqs && hasRequirement(item)) 
    || (TYPES.some(type => heldItemDesc(heldItemName).includes(type)) && heldItemName !== 'Chilan Berry');
}

function isLegalItem(item, ignoreLastRoundReq) {
  if (item.weight != null && !(Math.random() < item.weight))
    return false;
  
  if (hasRequirement(item)) { // if there are required conditions...
    let satisfied = false;
    for (const pokemonStr of getPartyStrs()) { // only one required condition needs to be fulfilled
      if (item.requiredSpecies?.includes(getSpeciesIdOfPokemon(pokemonStr)))
        satisfied = true;
      if (item.requiredAbilities?.includes(getAbilityNameOfPokemon(pokemonStr)))
        satisfied = true;
      if (item.requiredMoves?.some(moveName => pokemonHasMove(pokemonStr, moveName)))
        satisfied = true;
    }
    if (!satisfied)
      return false;
  }

  const partySize = getPartyStrs().length;
  if (item.minPartySize != null && partySize < item.minPartySize)
    return false;
  if (item.bannedIfPartyNotFull && partySize < getPartyPokeDivs().length)
    return false;
  if (item.bannedIfPartyFull && partySize === getPartyPokeDivs().length)
    return false;
  if (item.bannedIfBoss && (isBoss() || isVsBoss()))
    return false;

  if (item.bannedFirstRound && roundCounter <= 1)
    return false;
  if (!ignoreLastRoundReq && (item.bannedLastRound || isNextBattleItem(item)) && roundCounter >= getNumRounds())
    return false;

  return true;
}
function hasRequirement(item) {
  return item.requiredSpecies != null || item.requiredAbilities != null || item.requiredMoves != null;
}

function getItemPrice(item) {
  let price = item.price;
  if (typeof price !== 'string')
    return price;
  if (price.includes('n')) { // number of party members
    const partyStrs = getPartyStrs();
    let n = 0;
    for (const pokemonStr of partyStrs) {
      if (getEffectiveStatTotal(...getStatRelevantInfo(pokemonStr), getAbilityNameOfPokemon(pokemonStr)) < STAT_TOTAL_GOAL/2)
        n += 1/2; // halve n for weak allies, like Eggs
      else
        n += 1; 
    }
    return roundToNearest5(resolveANplusB(price, 'n', n), true);
  } else if (price.includes('m')) { // how many more Pokemon will be added
    const numEmptySlots = getPartyPokeDivs().length  - getPartyStrs().length;
    const numRoundsLeft = getNumRounds() - roundCounter;
    let expectedNumAddedPoke = Math.min(numEmptySlots, numRoundsLeft);
    if (numEmptySlots === 0 && numRoundsLeft > 0)
      expectedNumAddedPoke = 0.5;
    if (isBoss())
      expectedNumAddedPoke *= 0.5; // halve m for Lv1 allies
    return roundToNearest5(resolveANplusB(price, 'm', expectedNumAddedPoke), true);
  } else if (price.includes('r')) // number of rounds left
    return roundToNearest5(resolveANplusB(price, 'r', getNumRounds() - roundCounter), true);
  else if (price.includes('/b')) // 1 / (number of battles left)
    return roundToNearest5(resolveANplusB(price, '/b', 1 / (getNumRounds() - roundCounter + 1)), true);
  else
    return parseInt(price);
}
// for handling item prices of the form an, an+b, or an-b
function resolveANplusB(str, nStr, nNum) {
  const splitByN = str.split(nStr);
  let a = parseFloat(splitByN[0]);
  if (isNaN(a))
    a = 1;
  let b = parseFloat(splitByN[1]);
  if (isNaN(b))
    b = 0;
  return a * nNum + b;
}

function createItemDiv(item, isExtra) {
  const itemDiv = document.createElement('div');
  itemDiv.classList.add('flex-row', 'mt-1', 'mb-1');

  const freezeInput = document.createElement('input');
  freezeInput.type = 'checkbox';
  freezeInput.classList.add('checkbox');
  if (isExtra)
    freezeInput.disabled = true;
  freezeInput.hidden = true; // effectively removes freezeInput

  const itemEle = document.createElement('div');
  itemEle.classList.add('info-box', 'item');
  itemEle.innerHTML = itemInHTML(item);

  const itemPrice = getItemPrice(item);

  const itemPriceEle = document.createElement('div');
  itemPriceEle.classList.add('info-box', 'item-price', 'flex-col-centered');
  const priceEle = document.createElement('h2');
  priceEle.classList.add('mb-4px');
  priceEle.innerText = '$' + itemPrice;
  const buyButton = document.createElement('button');
  buyButton.classList.add('mb-4px');
  buyButton.onclick = function() {buyItem(itemDiv, item, itemPrice)};
  buyButton.innerText = 'buy';
  if (itemPrice < 0) {
    priceEle.classList.add('green');
    priceEle.innerText = '+$' + -1 * itemPrice;
    buyButton.innerText = 'earn';
  }
  itemPriceEle.append(priceEle, buyButton);

  itemDiv.append(freezeInput, itemEle, itemPriceEle);
  return itemDiv;
}
function itemInHTML(item) {
  return '<span class="' + item.type + ' big-text">' + item.name + '</span>'
            + '\n' + itemDescInHTML(item.desc, !((item.type.includes('TM') && item.type !== 'beforeTM') || item.type === 'egg'));
}
const KEYWORD_HOVER_TEXTS = {
  // ORDER MATTERS! Keywords can accidentally be found within other keywords' hover text.
  'held item': 'e.g. "Pikachu (F) @ Leftovers"',
  'EVs': 'e.g. "EVs: 1 HP / 252 SpA"',
  'EV': 'e.g. "EVs: 1 HP / 252 SpA"',
  'Nature': 'add a new line under EVs\ne.g. "Bold Nature"',
  'gender': 'e.g. "Pikachu (F)"',
  'Next battle only': 'Revealed after both players are ready for battle.\nCannot be used on the final battle.',
  'Before battle': 'Revealed after both players are ready for battle.',
  'nth': 'Before it happens, choose between 1st, 2nd, 3rd, etc. Must be valid (as far as you know).',
  'mth': 'Before it happens, choose between 1st, 2nd, 3rd, etc. Must be valid (as far as you know).',
  'pth': 'Before it happens, choose between 1st, 2nd, 3rd, etc. Must be valid (as far as you know).',
  'qth': 'Before it happens, choose between 1st, 2nd, 3rd, etc. Must be valid (as far as you know).',
  '_____': 'Before it happens, choose what goes in this blank.',
};
function itemDescInHTML(itemDesc, handleKeywords) {
  if (handleKeywords) {
    for (const [keyword, hoverText] of Object.entries(KEYWORD_HOVER_TEXTS)) {
      const regexp = new RegExp('\\b'+keyword+'\\b', '');
      if (itemDesc.match(regexp)) {
        itemDesc = itemDesc.replace(regexp, spanWithTitle(keyword, hoverText));
      }
    }
  }

  const splitByAsterisk = itemDesc.split('*');
  itemDesc = '';
  for (let i = 0; i < splitByAsterisk.length; i++) {
    let str = splitByAsterisk[i];
    if (i % 2 == 1) {
      if (getMoveId(str))
        str = moveInHTML(str);
      else if (getAbilityId(str))
        str = abilityInHTML(str);
      else if (getHeldItemId(str))
        str = heldItemInHTML(str);
    }
    itemDesc += str;
  }
  return itemDesc;
}

function abilityInHTML(abilityName) {
  let html = abilityNameInHTML(abilityName);
  const ability = abilities[getAbilityId(abilityName)];
  if (ability)
    html = spanWithTitle(html, abilityDesc(ability));
  return html;
}
function abilityNameInHTML(abilityName) {
  if (ABILITIES_WITH_UNEXPECTED_DESC.includes(abilityName))
    abilityName = spanWithClass(abilityName, 'abilityUnexpected');
  if (DO_NOTHING_ABILITIES.includes(abilityName))
    abilityName = spanWithClass(abilityName, 'attr');
  if (IMPROVED_ABILITIES[abilityName])
    abilityName = spanWithClass(abilityName, 'improvedAbility');
  return abilityName;
}
function abilityDesc(ability) {
  if (CHANGED_ABILITY_DESC[ability.name])
    return CHANGED_ABILITY_DESC[ability.name];
  if (IMPROVED_ABILITIES[ability.name])
    return IMPROVED_ABILITIES[ability.name];
  return ability.shortDesc;
}

const OGERPON_TERA_TYPES = ['Grass', 'Fire', 'Water', 'Rock'];
function isOgerpon(species) {
  return species.name.includes('Ogerpon');
}

function heldItemInHTML(heldItemName) {
  return spanWithTitle(heldItemNameInHTML(heldItemName), heldItemDesc(heldItemName));
}
function heldItemNameInHTML(heldItemName) {
  if (IMPROVED_ITEMS[heldItemName])
    heldItemName = spanWithClass(heldItemName, 'improvedItem');
  return heldItemName;
}
function heldItemDesc(heldItemName) {
  let desc = '';
  const heldItem = heldItems[getHeldItemId(heldItemName)];

  if (IMPROVED_ITEMS[heldItemName])
    desc = IMPROVED_ITEMS[heldItemName];
  else {
    if (heldItemName === 'Utility Umbrella')
      desc = heldItem.desc;
    else
      desc = heldItem.shortDesc ?? heldItem.desc;
  }

  if (getPartyStrs().some(pokemonStr => pokemonHasMove(pokemonStr, 'Fling')) && heldItem.fling) {
    let bonus = '';
    switch (heldItemName) {
      case 'Flame Orb':
        bonus = ' and inflicts Burn';
        break;
      case "King's Rock":
      case "Razor Fang":
        bonus = ' and causes guaranteed flinch';
        break;
      case "Light Ball":
        bonus = ' and inflicts Paralysis';
        break;   
      case "Mental Herb":
      case "White Herb":
        bonus = ' and cures target';
        break;
      case "Poison Barb":
        bonus = ' and inflicts Poison';
        break;
      case "Toxic Orb":
        bonus = ' and inflicts Badly Poisoned';
        break;
    }
    if (desc.indexOf('\n\n') !== -1)
      desc += '\n'; // Add an extra newline for TRs, which have the entire move in its desc
    desc += '\n(Fling: ' + heldItem.fling.basePower + ' power' + bonus + '.)';
  }
  return desc;
}

function randomEgg() {
  const speciesName = randomSpeciesName(null, ['pokestarspirit', 'shedinja'], true);
  let pokemonStr = randomOfSpecies(speciesName, null, null, 1, 'random', true, false)
                    + '\n- Splash\n- \n- \n- ';
  return {
    name: speciesName + ' Egg',
    type: 'egg',
    price: '2r+50',
    desc: 'ADD the following Pokemon in an EXTRA SLOT:\n' 
            + spanWithClass(pokemonInHTML(pokemonStr), 'attr'),
  };
}

const MIN_TRANSFORMER_STAT_DIFF = -50;
const MAX_TRANSFORMER_STAT_DIFF = 100;
function randomTransformer() {
  const partyIndex = getTmSeekerIndex();
  const pokemonStr = getPartyStrs()[partyIndex];
  if (getAbilityNameOfPokemon(pokemonStr) === 'Wonder Guard')
    return randomTM();

  let statMultiplier = 1; // how much stats will multiply by, by the end
  if (isBoss() && partyIndex === 0) {
    // note this doesn't account for Atk/SpA multiplying faster, or
    // the fact that early battles don't have all the level-ups yet 
    let levelUpsLeft = bossLevelUps.length;
    statMultiplier = Math.pow(startingNumSlots, 1/4) / Math.pow(startingNumSlots - levelUpsLeft, 1/4);
  }
  const apparentPrevSpeciesName = getApparentSpeciesNameOfPokemon(pokemonStr);
  
  newSpeciesInfo = randomTransformedSpeciesForPokemon(pokemonStr, 
          MIN_TRANSFORMER_STAT_DIFF / statMultiplier, MAX_TRANSFORMER_STAT_DIFF / statMultiplier);
  if (newSpeciesInfo === null) {
    console.error("Couldn't find a valid transformer for " + apparentPrevSpeciesName);
    return randomTM();
  }

  let price = 10 + roundToNearest5(newSpeciesInfo.effectiveStatDiff * statMultiplier);
  let typesHtml = '<div class="types">' + getTypesHTML(newSpeciesInfo.species.types, true, true) + '</div>';
  if (isCamomons()) {
    price -= 5;
    typesHtml = '';
  }
  return {
    name: apparentPrevSpeciesName + ' ‚Üí ' + newSpeciesInfo.speciesName,
    type: 'transformer',
    price: price,
    desc: 'Change your ' + ordinal(partyIndex+1) + ' Pokemon from ' + aOrAn(apparentPrevSpeciesName) + ' into ' + aOrAn(newSpeciesInfo.speciesName) + '. '
            + 'Its gender, ability, etc. stays the same.\n'
            + typesHtml
            + spanWithClass(statsInHTML(newSpeciesInfo.statInfo, false), 'attr'),
  }
}
function randomTransformedSpeciesForPokemon(pokemonStr, minStatDiff, maxStatDiff) {
  const prevStatInfo = getStatRelevantInfo(pokemonStr);
  const abilityName = getAbilityNameOfPokemon(pokemonStr);
  const prevEffectiveStatTotal = getEffectiveStatTotal(...prevStatInfo, abilityName);
  
  return randomTransformedSpecies(prevStatInfo, abilityName, prevEffectiveStatTotal, minStatDiff, maxStatDiff);
}
function randomTransformedSpecies(prevStatInfo, abilityName, prevEffectiveStatTotal, minStatDiff, maxStatDiff) {
  const outputOptions = [];
  for (const [speciesId, species] of Object.entries(allSpecies)) {
    if (!isLegal(speciesId, null, true))
      continue;
    if (prevStatInfo[0] === species) // same species
      continue;
    
    const statInfo = [...prevStatInfo];
    statInfo[0] = species;
    const effectiveStatTotal = getEffectiveStatTotal(...statInfo, abilityName);
    const effectiveStatDiff = effectiveStatTotal - prevEffectiveStatTotal;
  
    if (effectiveStatDiff < minStatDiff || maxStatDiff < effectiveStatDiff)
      continue;
  
    outputOptions.push({
      speciesName: randomCosmeticName(species),
      species: species,
      effectiveStatDiff: effectiveStatDiff,
      statInfo: statInfo,
    });
  }

  if (outputOptions.length === 0)
    return null;
  return randomElement(outputOptions);
}

const MIN_ABILITIZER_PRICE = -100;
const MAX_ABILITIZER_PRICE = Infinity;
function randomAbilitizer(failsafe) {
  if (failsafe-- < 0) {
    console.error("Couldn't find a valid abilitizer!");
    return randomTM();
  }

  const ability = randomAbilitizerAbility();
  // const ability = abilities.drought;
  let abilitizer = {
    name: 'Abilitizer #' + ability.num,
    type: 'abilitizer',
    price: 20 + abilitizerPrice(ability),
    desc: abilitizerDesc("Set a Pokemon's ability to ", ability),
  };

  let randy = Math.random();
  const twinAbilitizerPrice = 10 + abilitizerPrice(ability); // used in if-conditional
  if ((randy -= .05) < 0 && !(ability.name === 'Plus' || ability.name === 'Minus')) {
      // Party Abilitizer
      const effectiveStatDiffs = [];
      for (const pokemonStr of getPartyStrs()) {
        const speciesName = getSpeciesNameOfPokemon(pokemonStr);
        const prevAbilityName = getAbilityNameOfPokemon(pokemonStr);
        if (IRREPLACEABLE_ABILITIES.includes(prevAbilityName))
          continue;

        const statInfo = getStatRelevantInfo(pokemonStr);
        effectiveStatDiffs.push(getEffectiveStatTotal(...statInfo, ability.name) - getEffectiveStatTotal(...statInfo, prevAbilityName));
      }
      if (effectiveStatDiffs.length === 0)
        effectiveStatDiffs.push(typicalEffectiveStatDiff);

    abilitizer = {
      name: 'Party Abilitizer #' + ability.num,
      type: 'partyAbilitizer',
      price: 20 + roundToNearest5(sumArr(effectiveStatDiffs)),
      desc: abilitizerDesc("Set EVERY Pokemon's ability to ", ability),
    };
  } else if ((randy -= .05) < 0 && twinAbilitizerPrice >= 0) {
    // Twin Abilitizers
    abilitizer = {
      name: 'Twin Abilitizers #' + ability.num,
      type: 'beforeAbilitizer',
      price: twinAbilitizerPrice,
      desc: abilitizerDesc("Before battle: Both players MAY set their [nth] Pokemon's ability to ", ability),
    }
  } else if ((randy -= .05) < 0) {
    // Binary Abilitizers
    let ability2;
    do {
      ability2 = randomAbilitizerAbility();
    } while (ability2 == ability);
    abilitizer = {
      name: 'Binary Abilitizers #' + ability.num + ' and #' + ability2.num,
      type: 'beforeAbilitizer',
      price: 5 + Math.min(abilitizerPrice(ability), abilitizerPrice(ability2)),
      desc: binaryAbilitizerDesc("Before battle: Your opponent chooses whether you set 1 of your Pokemon's ability to ", ability, ' or ', ability2),
    }
  }
  
  if (abilitizer.price < MIN_ABILITIZER_PRICE || MAX_ABILITIZER_PRICE < abilitizer.price)
    return randomAbilitizer(failsafe); // re-roll
  return abilitizer;
}
function randomAbilitizerAbility() {
  let ability;
  do {
    ability = randomValue(abilities);
  } while (!isRandomableAbility(ability));
  return ability;
}
function isRandomableAbility(ability) {
  return !(ability.desc.includes('f this Pokemon is a ') || ability.desc.includes('f this Pokemon is an ')
            || ability.name.substring(0, 'Embody Aspect'.length) === 'Embody Aspect'
            || ability.name === 'Teraform Zero' // Tera Shift and Tera Shell are in the 'if this Pokemon is a' case
            || ability.name === 'Wonder Guard');
}
function abilitizerDesc(strBeforeAbilityName, ability) {
  return strBeforeAbilityName + abilityNameInHTML(ability.name) + '.\n'
          + spanWithClass(abilityDesc(ability), 'attr') + '\n'
          + spanWithClass("Cannot replace " + enumerateWithOr(IRREPLACEABLE_ABILITIES) + '.', 'warning');
}
function binaryAbilitizerDesc(str, ability, str2, ability2) {
  return str + abilityNameInHTML(ability.name) + str2 + abilityNameInHTML(ability2.name) + '.\n'
          + twoEqualWidthAttr(abilityDesc(ability), abilityDesc(ability2))
          + spanWithClass("Cannot replace " + enumerateWithOr(IRREPLACEABLE_ABILITIES) + '.', 'warning');
}
function abilitizerPrice(ability) {
  const typicalEffectiveStatDiff = STAT_TOTAL_GOAL * (getAbilityValue(null, ability.name) - BASE_ABILITY_VALUE);
  return roundToNearest5(typicalEffectiveStatDiff);
}

function roundToNearest5(num, canRoundToOnes) {
  if (canRoundToOnes) {
    if ((0+1)/2 <= num && num < (0+5)/2)
      return 1;
    if ((0-1)/2 > num && num >= (0-5)/2)
      return -1;
  }
  return 5 * Math.round(num/5);
}

function getAbilityNameOfPokemon(pokemonStr) {
  const abilityLine = pokemonStr.split('\n').find(line => line.startsWith('Ability:'));
  return abilityLine.substring('Ability: '.length);
}

function getHeldItemOfPokemon(pokemonStr) {
  return heldItems[getHeldItemId(getHeldItemNameOfPokemon(pokemonStr))];
}
function getHeldItemNameOfPokemon(pokemonStr) {
  let firstLine = pokemonStr.substring(0, pokemonStr.indexOf('\n'));
  let atIndex = firstLine.indexOf(' @ ');
  if (atIndex === -1)
    return null;
  else
    return firstLine.substring(atIndex + ' @ '.length);
}

const UNIVERSAL_TM_PREFIX = 'Teach ANY 1 Pokemon the move ';
function randomTM() {
  let randy = Math.random();

  if ((randy -= .35) < 0) {
    // Universal TM
    const move = randomMove(true);
    return {
      name: 'Universal TM #' + move.num,
      type: 'universalTM',
      price: tmPrice(move) + 10,
      desc: tmDesc(UNIVERSAL_TM_PREFIX, move),
    };
  } else if ((randy -= .05) < 0) {
    // Party TM
    const move = randomMove(true);
    return {
      name: 'Party TM #' + move.num,
      type: 'partyTM',
      price: (tmPrice(move)/2 - 3) + 'n+' + (tmPrice(move)/2 + 3 + 10),
      desc: tmDesc('EVERY Pokemon MUST learn ', move),
    };
  } else if ((randy -= .05) < 0) {
    // Twin TMs
    const move = randomMove(true);
    return {
      name: 'Twin TMs #' + move.num,
      type: 'beforeTM',
      price: roundToNearest5(tmPrice(move)/2, true),
      desc: tmDesc("Before battle: Both players MAY teach their [nth] Pokemon the move ", move),
    };
  } else if ((randy -= .05) < 0) {
    // Binary TMs
    const move = randomMove(true, (move) => tmPrice(move) <= 100);
    const move2 = randomMove(true, (oMove) => Math.abs(tmPrice(oMove) - tmPrice(move)) <= 10 && oMove != move);
    return {
      name: 'Binary TMs #' + move.num + ' and #' + move2.num,
      type: 'beforeTM',
      price: roundToNearest5(Math.min(tmPrice(move), tmPrice(move2)), true),
      desc: binaryTmDesc('Before battle: Your opponent chooses whether you teach 1 of your Pokemon the move ', move, ' or ', move2),
    };
  } else if ((randy -= .25) < 0) {
    // Type-based Species TM
    const typeMultiset = [];
    const correspondingPkmnStrs = [];
    const tmSeekingMon = getPartyStrs()[getTmSeekerIndex()];
    const pokemonStrs = [tmSeekingMon];
    for (const pokemonStr of pokemonStrs) {
      const speciesTypes = allSpecies[getSpeciesIdOfPokemon(pokemonStr)].types;
      for (let i = 0; i < 2; i++) {
        let speciesType = speciesTypes[i];
        if (!speciesType)
          speciesType = speciesTypes[0]; // add another copy, for balance
        if (!TYPES.includes(speciesType))
          speciesType = 'Normal';
        typeMultiset.push(speciesType);
        correspondingPkmnStrs.push(pokemonStr);
      }
    }
      
    const index = randomInt(typeMultiset.length);
    const type = typeMultiset[index];
    const speciesName = getApparentSpeciesNameOfPokemon(correspondingPkmnStrs[index]);
    let move;
    do {
      move = randomMove(true);
    } while (!(move.type === type && !pokemonHasMove(correspondingPkmnStrs[index], move.name)));
    return {
      name: type + ' ' + speciesName + ' TM #' + move.num,
      type: 'speciesTM',
      price: tmPrice(move) + 5,
      desc: tmDesc('Teach ' + speciesName + ' the move ', move),
    };
  } else {
    // Species TM
    let possibleMoves = [];
    let speciesNames = [];
    let pokemonStrs = [getPartyStrs()[getTmSeekerIndex()]];
    for (const pokemonStr of pokemonStrs) {
      const speciesName = getApparentSpeciesNameOfPokemon(pokemonStr);
      const speciesId = getSpeciesId(speciesName);
      for (const moveId of getLearnset(speciesId)) {
        const move = addHiddenPowerType(moves[moveId]);
        if (prevSeenItems.has(speciesTM(speciesName, move, false).name))
          continue;
        if (pokemonHasMove(pokemonStr, move.name))
          continue;
        possibleMoves.push(move);
        speciesNames.push(speciesName);
      }
    }

    let speciesName, move;
    let isImpossibleTM = false;
    if (possibleMoves.length == 0) {
      isImpossibleTM = true;
      const pokemonStr = randomElement(pokemonStrs);
      speciesName = getApparentSpeciesNameOfPokemon(pokemonStr);
      do {
        move = randomMove(true);
      } while (pokemonHasMove(pokemonStr, move.name));
    } else {
      const possibleMovesIndex = randomInt(possibleMoves.length);
      speciesName = speciesNames[possibleMovesIndex];
      move = possibleMoves[possibleMovesIndex];
    }

    return speciesTM(speciesName, move, isImpossibleTM);
  }
}
function speciesTM(speciesName, move, isImpossibleTM) {
  return {
    name: (isImpossibleTM ? 'Impossible ' : '') + speciesName + ' TM #' + move.num,
    type: 'speciesTM',
    price: tmPrice(move) + (isImpossibleTM ? 5 : 0),
    desc: tmDesc('Teach ' + speciesName + ' the move ', move),
  };
}
function tmPrice(move) {
  if (move.name === 'Clangorous Soulblaze')
    return 150;
  else if (move.name === 'Extreme Evoboost')
    return 150;
  else if (isZ(move))
    return 80;
  else if (isLGPE(move))
    return 40;
  else if (move.basePower >= 80)
    return 20;
  else if (move.basePower >= 70)
    return 15;
  else
    return 10;
}
// these functions are about power levels, not if it's literally a Z-Move/Let's Go move
const SIXTH_HP_PER_TURN = ["G-Max Cannonade", "G-Max Vine Lash", "G-Max Volcalith", "G-Max Wildfire"];
function isZ(move) {
  return move.isZ || move.name === 'Spore' || move.name === 'Zippy Zap' || SIXTH_HP_PER_TURN.includes(move.name);
}
const LGPE_POWER_MOVES = ['Baddy Bad', 'Glitzy Glow', 'G-Max Resonance', 'Sizzly Slide', 'Buzzy Buzz', 'Sparkly Swirl'];
function isLGPE(move) {
  return LGPE_POWER_MOVES.includes(move.name);
}
function tmDesc(strBeforeMoveName, move) {
  return strBeforeMoveName + spanWithType(move.name, move.type) + '.'
          + '\n' + spanWithClass(moveDesc(move, true), 'attr');
}
function binaryTmDesc(str, move, str2, move2) {
  return str + spanWithType(move.name, move.type) + str2 + spanWithType(move2.name, move2.type) + '.'
          + '\n' + twoEqualWidthAttr(moveDesc(move, true), moveDesc(move2, true));
}
function twoEqualWidthAttr(str, str2) {
  return '<div class="flex-row attr">' 
            + spanWithClass(str, 'equalWidth mr-half') 
            + spanWithClass(str2, 'equalWidth') 
            + '</div>';
}
function randomMove(allowZMoves, predicate) {
  let move = randomValue(moves);
  while (!isLegalMove(move, allowZMoves, true) || (predicate && !predicate(move)))
    move = randomValue(moves);
  return addHiddenPowerType(move);
}
function isLegalMove(move, allowZMoves, allowGMaxMoves) {
  return !(
       move.desc === "Power is equal to the base move's Z-Power." 
    || move.name.startsWith('Max') 
    || (move.name.startsWith('G-Max') && (!allowGMaxMoves || move.basePower === 160))
    || (isZ(move) && !allowZMoves)
    || move.desc?.includes('cannot be used successfully')
  );
}

function getTmSeekerIndex() {
  return document.getElementById('tmSeeker').selectedIndex;
}

function addHiddenPowerType(move) {
  if (move.name === 'Hidden Power') {
    let type = 'Normal';
    while (type === 'Normal' || type === 'Fairy')
      type = randomElement(TYPES);
    return moves['hiddenpower' + type.toLowerCase()];
  } else {
    return move;
  }
}

function ordinal(n) {
  switch (n) {
    case 1: return '1st';
    case 2: return '2nd';
    case 3: return '3rd';
    default: return n + 'th';
  }
}

function aOrAn(str) {
  const firstChar = str.charAt(0).toLowerCase();
  if (['a', 'e', 'i', 'o', 'u'].includes(firstChar))
    return 'an ' + str;
  return 'a ' + str;
}


function enumerateWithOr(strArr) {
  if (strArr.length === 1)
    return strArr[0];
  if (strArr.length === 2)
    return strArr[0] + ' or ' + strArr[1];
  let out = '';
  for (let i = 0; i < strArr.length - 1; i++)
    out += strArr[i] + ', ';
  out += 'or ' + strArr[strArr.length-1];
  return out;
}

function buyItem(itemDiv, item, itemPrice) {
  if (isNextBattleItem(item) && roundCounter >= getNumRounds()) {
    alert('Sorry! "Next battle only" items cannot be used on the final battle.');
    return;
  }

  if (!pay(itemPrice)) return;

  if (!(numOfKeyItem(KEY_ITEMS.RE_BUY) > 0 && !(itemPrice < 0 || item.desc.includes('earn $')))) {
    // replace buy button with checkmark
    const buyButton = itemDiv.querySelector('button');
    const checkmarkEle = document.createElement('h2');
    checkmarkEle.classList.add('mb-4px');
    checkmarkEle.textContent = '‚úÖ';
    buyButton.insertAdjacentElement('afterend', checkmarkEle);
    buyButton.remove();
    // hide freeze checkbox
    const checkbox = itemDiv.querySelector('input');
    checkbox.checked = false;
    checkbox.classList.add('invisible');
  }

  itemDiv.classList.add('chosen');

  if (item.type === 'pokeball') {
    if (item.name === 'Random Ball') {
      const pokeballs = getAllPokeballNames();
      pokeballs.shift();
      setPokeball(randomElement(pokeballs));
    }
    else
      setPokeball(item.name);
    // document.getElementById('pokeballDiv').hidden = false;

  } else if (item.name.startsWith('Encounter Power: ')) {
    const type = item.name.split(' ')[2];
    setGuaranteedType(TYPES.includes(type) ? type : '');

  } else if (isBeforeBattleItem(item)) {
    addItemDescToEle(item.desc, 'beforeBattle');
  
  } else if (isNextBattleItem(item)) {
    addItemDescToEle(item.desc, 'nextBattle');

  } else if (item.type === 'keyItem') {
    document.getElementById('keyItemsDiv').hidden = false;
    let keyItemsStr = document.getElementById('keyItems').innerText;
    keyItemsStr = keyItemsStr.trimEnd();
    keyItemsStr += '\n' + item.name;
    keyItemsStr = keyItemsStr.trimStart();
    document.getElementById('keyItems').innerText = keyItemsStr;
    updateKeyItemsEle();

    // if it's a magnet, Guaranteed Type is also set on-buy
    const type = getMagnetType(item.name);
    if (type)
      setGuaranteedType(type);
  }
}

function getMagnetType(itemName) {
  for (const type of TYPES) {
    if (KEY_ITEMS[type.toUpperCase() + '_MAGNET'] === itemName)
      return type;
  }
  return null;
}

function addItemDescToEle(itemDesc, elementId) {
  document.getElementById(elementId + 'Div').hidden = false;

  let pHTML = itemDesc.substring(itemDesc.indexOf(': ') + ': '.length);
  pHTML = replaceWithHTMLInputs(pHTML);
  pHTML = itemDescInHTML(pHTML, true);
  
  const p = document.createElement('p');
  p.innerHTML = pHTML;
  document.getElementById(elementId).append(p);
}

let NTH_SELECT_HTML;
NTH_SELECT_HTML = '<select>';
for (let i = 1; i <= 10; i++) {
  NTH_SELECT_HTML += '<option>' + ordinal(i) + '</option>';
}
NTH_SELECT_HTML += '</select>';
function replaceWithHTMLInputs(itemHTML) {
  return itemHTML.replaceAll('[nth]', NTH_SELECT_HTML)
                 .replaceAll('[mth]', NTH_SELECT_HTML)
                 .replaceAll('[pth]', NTH_SELECT_HTML)
                 .replaceAll('[qth]', NTH_SELECT_HTML)
                 .replaceAll('[_____]', '<input size="7">');
}


function isBeforeBattleItem(item) {
  return item.desc.startsWith('Before battle: ');
}
function isNextBattleItem(item) {
  return item.desc.startsWith('Next battle only: ');
}

function pay(price) {
  let money = getMoney();
  if (money == null) {
    return false;
  } else if (money < price) {
    alert('Not enough money!');
    return false;
  } else {
    setMoney(money - price);
    return true;
  }
}
function getMoney() {
  let money = parseInt(getMoneyStr());
  if (isNaN(money)) {
    alert('Invalid money value!');
    return null;
  }
  return money;
}
function getMoneyStr() {
  return document.getElementById('money').value;
}
function setMoney(money) {
  document.getElementById('money').value = money;
  updateTax();
}

function getTax(money) {
  return Math.floor(money / 10);
}

function updateTax() {
  const money = getMoney();
  if (money == null)
    return;
  const tax = getTax(money);
  document.getElementById('tax').textContent = tax;
  if (tax === 0)
    document.getElementById('taxDiv').classList.replace('attr', 'gray');
  else
    document.getElementById('taxDiv').classList.replace('gray', 'attr'); 
}

function getPokeball() {
  return document.getElementById('pokeball').value;
}
function setPokeball(pokeball) {
  document.getElementById('pokeball').value = pokeball;
  updatePokeballDesc(pokeball);
}
function updatePokeballDesc(pokeball) {
  const pokeballDescEle = document.getElementById('pokeballDesc');
  const pokeballItem = items.find(item => item.name === pokeball);
  const pokeballDesc = pokeballItem ? pokeballItem.desc : '';
  pokeballDescEle.textContent = pokeballDesc.replaceAll('*', '');

  const guaranteedTypeEle = document.getElementById('guaranteedTypeLabel');
  if (POKEBALL_PROMPTS[pokeball] !== undefined || pokeball === 'Wonder Ball')
    guaranteedTypeEle.classList.add('strikethrough');
  else
    guaranteedTypeEle.classList.remove('strikethrough');
}

function getGuaranteedType() {
  return document.getElementById('type').value;
}
function setGuaranteedType(type) {
  document.getElementById('type').value = type;
}

function randomValue(obj) {
  return obj[randomKey(obj)];
}

function randomElement(array) {
  return array[randomInt(array.length)];
}
function randomKey(obj) {
  const keys = Object.keys(obj);
  return keys[randomInt(keys.length)];
}

function randomInt(max) {
  return Math.floor(Math.random() * max); 
}

function chainAttack() {
  let successes = 0;
  const TRIALS = 1000000;
  for (let i = 0; i < TRIALS; i++) {
    const party = [true, true, true, true, true, true];
    let has0 = false;
    let has1 = false;
    for (let j = 0; j < 3; j++) {
      const options = [];
      for (let k = 0; k < 3; k++) {
        let option;
        do {
          option = randomInt(party.length);
        } while (!party[option] || options.includes(option));
        options.push(option);
      }
      let choice;
      if (options.includes(0)) {
        choice = 0;
        has0 = true;
      } else if (options.includes(1)) {
        choice = 1;
        has1 = true;
      } else {
        choice = options[0];
      }
      party[choice] = false;
    }
    if (has0 && has1)
      successes++;
  }
  console.log(successes / TRIALS);
}

</script>

</body>
</html>
